(function(){var require = function (file, cwd) {
    var resolved = require.resolve(file, cwd || '/');
    var mod = require.modules[resolved];
    if (!mod) throw new Error(
        'Failed to resolve module ' + file + ', tried ' + resolved
    );
    var cached = require.cache[resolved];
    var res = cached? cached.exports : mod();
    return res;
};

require.paths = [];
require.modules = {};
require.cache = {};
require.extensions = [".js",".coffee",".json"];

require._core = {
    'assert': true,
    'events': true,
    'fs': true,
    'path': true,
    'vm': true
};

require.resolve = (function () {
    return function (x, cwd) {
        if (!cwd) cwd = '/';
        
        if (require._core[x]) return x;
        var path = require.modules.path();
        cwd = path.resolve('/', cwd);
        var y = cwd || '/';
        
        if (x.match(/^(?:\.\.?\/|\/)/)) {
            var m = loadAsFileSync(path.resolve(y, x))
                || loadAsDirectorySync(path.resolve(y, x));
            if (m) return m;
        }
        
        var n = loadNodeModulesSync(x, y);
        if (n) return n;
        
        throw new Error("Cannot find module '" + x + "'");
        
        function loadAsFileSync (x) {
            x = path.normalize(x);
            if (require.modules[x]) {
                return x;
            }
            
            for (var i = 0; i < require.extensions.length; i++) {
                var ext = require.extensions[i];
                if (require.modules[x + ext]) return x + ext;
            }
        }
        
        function loadAsDirectorySync (x) {
            x = x.replace(/\/+$/, '');
            var pkgfile = path.normalize(x + '/package.json');
            if (require.modules[pkgfile]) {
                var pkg = require.modules[pkgfile]();
                var b = pkg.browserify;
                if (typeof b === 'object' && b.main) {
                    var m = loadAsFileSync(path.resolve(x, b.main));
                    if (m) return m;
                }
                else if (typeof b === 'string') {
                    var m = loadAsFileSync(path.resolve(x, b));
                    if (m) return m;
                }
                else if (pkg.main) {
                    var m = loadAsFileSync(path.resolve(x, pkg.main));
                    if (m) return m;
                }
            }
            
            return loadAsFileSync(x + '/index');
        }
        
        function loadNodeModulesSync (x, start) {
            var dirs = nodeModulesPathsSync(start);
            for (var i = 0; i < dirs.length; i++) {
                var dir = dirs[i];
                var m = loadAsFileSync(dir + '/' + x);
                if (m) return m;
                var n = loadAsDirectorySync(dir + '/' + x);
                if (n) return n;
            }
            
            var m = loadAsFileSync(x);
            if (m) return m;
        }
        
        function nodeModulesPathsSync (start) {
            var parts;
            if (start === '/') parts = [ '' ];
            else parts = path.normalize(start).split('/');
            
            var dirs = [];
            for (var i = parts.length - 1; i >= 0; i--) {
                if (parts[i] === 'node_modules') continue;
                var dir = parts.slice(0, i + 1).join('/') + '/node_modules';
                dirs.push(dir);
            }
            
            return dirs;
        }
    };
})();

require.alias = function (from, to) {
    var path = require.modules.path();
    var res = null;
    try {
        res = require.resolve(from + '/package.json', '/');
    }
    catch (err) {
        res = require.resolve(from, '/');
    }
    var basedir = path.dirname(res);
    
    var keys = (Object.keys || function (obj) {
        var res = [];
        for (var key in obj) res.push(key);
        return res;
    })(require.modules);
    
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (key.slice(0, basedir.length + 1) === basedir + '/') {
            var f = key.slice(basedir.length);
            require.modules[to + f] = require.modules[basedir + f];
        }
        else if (key === basedir) {
            require.modules[to] = require.modules[basedir];
        }
    }
};

(function () {
    var process = {};
    
    require.define = function (filename, fn) {
        if (require.modules.__browserify_process) {
            process = require.modules.__browserify_process();
        }
        
        var dirname = require._core[filename]
            ? ''
            : require.modules.path().dirname(filename)
        ;
        
        var require_ = function (file) {
            var requiredModule = require(file, dirname);
            var cached = require.cache[require.resolve(file, dirname)];

            if (cached && cached.parent === null) {
                cached.parent = module_;
            }

            return requiredModule;
        };
        require_.resolve = function (name) {
            return require.resolve(name, dirname);
        };
        require_.modules = require.modules;
        require_.define = require.define;
        require_.cache = require.cache;
        var module_ = {
            id : filename,
            filename: filename,
            exports : {},
            loaded : false,
            parent: null
        };
        
        require.modules[filename] = function () {
            require.cache[filename] = module_;
            fn.call(
                module_.exports,
                require_,
                module_,
                module_.exports,
                dirname,
                filename,
                process
            );
            module_.loaded = true;
            return module_.exports;
        };
    };
})();


require.define("path",Function(['require','module','exports','__dirname','__filename','process'],"function filter (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (fn(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length; i >= 0; i--) {\n    var last = parts[i];\n    if (last == '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Regex to split a filename into [*, dir, basename, ext]\n// posix version\nvar splitPathRe = /^(.+\\/(?!$)|\\/)?((?:.+?)?(\\.[^.]*)?)$/;\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\nvar resolvedPath = '',\n    resolvedAbsolute = false;\n\nfor (var i = arguments.length; i >= -1 && !resolvedAbsolute; i--) {\n  var path = (i >= 0)\n      ? arguments[i]\n      : process.cwd();\n\n  // Skip empty and invalid entries\n  if (typeof path !== 'string' || !path) {\n    continue;\n  }\n\n  resolvedPath = path + '/' + resolvedPath;\n  resolvedAbsolute = path.charAt(0) === '/';\n}\n\n// At this point the path should be resolved to a full absolute path, but\n// handle relative paths to be safe (might happen when process.cwd() fails)\n\n// Normalize the path\nresolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\nvar isAbsolute = path.charAt(0) === '/',\n    trailingSlash = path.slice(-1) === '/';\n\n// Normalize the path\npath = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n  \n  return (isAbsolute ? '/' : '') + path;\n};\n\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n};\n\n\nexports.dirname = function(path) {\n  var dir = splitPathRe.exec(path)[1] || '';\n  var isWindows = false;\n  if (!dir) {\n    // No dirname\n    return '.';\n  } else if (dir.length === 1 ||\n      (isWindows && dir.length <= 3 && dir.charAt(1) === ':')) {\n    // It is just a slash or a drive letter with a slash\n    return dir;\n  } else {\n    // It is a full dirname, strip trailing slash\n    return dir.substring(0, dir.length - 1);\n  }\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPathRe.exec(path)[2] || '';\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPathRe.exec(path)[3] || '';\n};\n\n//@ sourceURL=path"
));

require.define("__browserify_process",Function(['require','module','exports','__dirname','__filename','process'],"var process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n        && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n        && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return window.setImmediate;\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'browserify-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('browserify-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    if (name === 'evals') return (require)('vm')\n    else throw new Error('No such module. (Possibly not yet loaded)')\n};\n\n(function () {\n    var cwd = '/';\n    var path;\n    process.cwd = function () { return cwd };\n    process.chdir = function (dir) {\n        if (!path) path = require('path');\n        cwd = path.resolve(dir, cwd);\n    };\n})();\n\n//@ sourceURL=__browserify_process"
));

require.define("/node_modules/JSONStream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/JSONStream/package.json"
));

require.define("/node_modules/JSONStream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"\nvar Parser = require('jsonparse')\n  , Stream = require('stream').Stream\n\n/*\n\n  the value of this.stack that creationix's jsonparse has is weird.\n  \n  it makes this code ugly, but his problem is way harder that mine,\n  so i'll forgive him.\n\n*/\n\nexports.parse = function (path) {\n  \n  var stream = new Stream()\n  var parser = new Parser()\n  var count = 0\n  if(!path.length)\n    path = null\n  parser.onValue = function () {\n    if(!this.root && this.stack.length == 1){\n      stream.root = this.value\n      }\n    if(!path || this.stack.length !== path.length)\n      return\n    var _path = []\n    for( var i = 0; i < (path.length - 1); i++) {\n      var key = path[i]\n      var c = this.stack[1 + (+i)]\n      \n      if(!c) {\n        return\n      }\n      var m = check(key, c.key)\n      _path.push(c.key)\n        \n       if(!m)\n        return\n      \n    }\n    var c = this\n \n    var key = path[path.length - 1]\n      var m = check(key, c.key)\n     if(!m)\n      return\n      _path.push(c.key)\n\n  count ++\n  stream.emit('data', this.value[this.key])\n  }\n\n\n  parser.onError = function (err) {\n    stream.emit('error', err)\n  }\n  stream.readable = true\n  stream.writable = true\n  stream.write = function (chunk) {\n    if('string' === typeof chunk) {\n      if ('undefined' === typeof Buffer) {\n        var buf = new Array(chunk.length)\n        for (var i = 0; i < chunk.length; i++) buf[i] = chunk.charCodeAt(i)\n        chunk = new Int32Array(buf)\n      } else {\n        chunk = new Buffer(chunk)\n      }\n    }\n    parser.write(chunk)\n  }\n  stream.end = function (data) {\n    if(data)\n      stream.write(data)\n    if(!count && !path)\n      stream.emit('data', stream.root)\n    stream.emit('end')\n  }\n  return stream\n}\n\nfunction check (x, y) {\n  if ('string' === typeof x)\n    return y == x\n  else if (x && 'function' === typeof x.exec)\n    return x.exec(y)\n  else if ('boolean' === typeof x)\n    return x\n  else if ('function' === typeof x)\n    return x(y)\n  return false\n}\n\nexports.stringify = function (op, sep, cl) {\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n  \n    op = '[\\n'\n    sep = '\\n,\\n'\n    cl = '\\n]\\n'\n  \n  }\n\n  //else, what ever you like\n  \n  var stream = new Stream ()\n    , first = true\n    , ended = false\n    , anyData = false\n  stream.write = function (data) {\n    anyData = true\n    var json = JSON.stringify(data)\n    if(first) { first = false ; stream.emit('data', op + json)}\n    else stream.emit('data', sep + json)\n  }\n  stream.end = function (data) {\n    if(ended)\n      return\n    ended = true\n    if(data) stream.write(data)\n    if(!anyData) stream.emit('data', op)\n    stream.emit('data', cl)\n    \n    stream.emit('end')\n  }\n  stream.writable = true\n  stream.readable = true\n\n  return stream\n}\n\nexports.stringifyObject = function (op, sep, cl) {\n  if (op === false){\n    op = ''\n    sep = '\\n'\n    cl = ''\n  } else if (op == null) {\n  \n    op = '{\\n'\n    sep = '\\n,\\n'\n    cl = '\\n}\\n'\n  \n  }\n\n  //else, what ever you like\n  \n  var stream = new Stream ()\n    , first = true\n    , ended = false\n    , anyData = false\n  stream.write = function (data) {\n    anyData = true\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1])\n    if(first) { first = false ; stream.emit('data', op + json)}\n    else stream.emit('data', sep + json)\n  }\n  stream.end = function (data) {\n    if(ended) return\n    ended = true\n    if(data) stream.write(data)\n    if(!anyData) stream.emit('data', op)\n    stream.emit('data', cl)\n    \n    stream.emit('end')\n  }\n  stream.writable = true\n  stream.readable = true\n\n  return stream\n}\n\n//@ sourceURL=/node_modules/JSONStream/index.js"
));

require.define("/node_modules/JSONStream/node_modules/jsonparse/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"jsonparse.js\"}\n//@ sourceURL=/node_modules/JSONStream/node_modules/jsonparse/package.json"
));

require.define("/node_modules/JSONStream/node_modules/jsonparse/jsonparse.js",Function(['require','module','exports','__dirname','__filename','process'],"/*global Buffer*/\n// Named constants with unique integer values\nvar C = {};\n// Tokens\nvar LEFT_BRACE    = C.LEFT_BRACE    = 0x1;\nvar RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;\nvar LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;\nvar RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;\nvar COLON         = C.COLON         = 0x5;\nvar COMMA         = C.COMMA         = 0x6;\nvar TRUE          = C.TRUE          = 0x7;\nvar FALSE         = C.FALSE         = 0x8;\nvar NULL          = C.NULL          = 0x9;\nvar STRING        = C.STRING        = 0xa;\nvar NUMBER        = C.NUMBER        = 0xb;\n// Tokenizer States\nvar START   = C.START   = 0x11;\nvar TRUE1   = C.TRUE1   = 0x21;\nvar TRUE2   = C.TRUE2   = 0x22;\nvar TRUE3   = C.TRUE3   = 0x23;\nvar FALSE1  = C.FALSE1  = 0x31;\nvar FALSE2  = C.FALSE2  = 0x32;\nvar FALSE3  = C.FALSE3  = 0x33;\nvar FALSE4  = C.FALSE4  = 0x34;\nvar NULL1   = C.NULL1   = 0x41;\nvar NULL2   = C.NULL3   = 0x42;\nvar NULL3   = C.NULL2   = 0x43;\nvar NUMBER1 = C.NUMBER1 = 0x51;\nvar NUMBER2 = C.NUMBER2 = 0x52;\nvar NUMBER3 = C.NUMBER3 = 0x53;\nvar NUMBER4 = C.NUMBER4 = 0x54;\nvar NUMBER5 = C.NUMBER5 = 0x55;\nvar NUMBER6 = C.NUMBER6 = 0x56;\nvar NUMBER7 = C.NUMBER7 = 0x57;\nvar NUMBER8 = C.NUMBER8 = 0x58;\nvar STRING1 = C.STRING1 = 0x61;\nvar STRING2 = C.STRING2 = 0x62;\nvar STRING3 = C.STRING3 = 0x63;\nvar STRING4 = C.STRING4 = 0x64;\nvar STRING5 = C.STRING5 = 0x65;\nvar STRING6 = C.STRING6 = 0x66;\n// Parser States\nvar VALUE   = C.VALUE   = 0x71;\nvar KEY     = C.KEY     = 0x72;\n// Parser Modes\nvar OBJECT  = C.OBJECT  = 0x81;\nvar ARRAY   = C.ARRAY   = 0x82;\n\n// Slow code to string converter (only used when throwing syntax errors)\nfunction toknam(code) {\n  var keys = Object.keys(C);\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    if (C[key] === code) { return key; }\n  }\n  return code && (\"0x\" + code.toString(16));\n}\n\n\nfunction Parser() {\n  this.tState = START;\n  this.value = undefined;\n\n  this.string = undefined; // string data\n  this.unicode = undefined; // unicode escapes\n\n  // For number parsing\n  this.negative = undefined;\n  this.magnatude = undefined;\n  this.position = undefined;\n  this.exponent = undefined;\n  this.negativeExponent = undefined;\n  \n  this.key = undefined;\n  this.mode = undefined;\n  this.stack = [];\n  this.state = VALUE;\n}\nvar proto = Parser.prototype;\nproto.charError = function (buffer, i) {\n  this.onError(new Error(\"Unexpected \" + JSON.stringify(String.fromCharCode(buffer[i])) + \" at position \" + i + \" in state \" + toknam(this.tState)));\n};\nproto.onError = function (err) { throw err; };\nproto.write = function (buffer) {\n  //process.stdout.write(\"Input: \");\n  //console.dir(buffer.toString());\n  var n;\n  for (var i = 0, l = buffer.length; i < l; i++) {\n    switch (this.tState) {\n    case START:\n      n = buffer[i];\n      switch (n) {\n      case 0x7b: this.onToken(LEFT_BRACE, \"{\"); break; // {\n      case 0x7d: this.onToken(RIGHT_BRACE, \"}\"); break; // }\n      case 0x5b: this.onToken(LEFT_BRACKET, \"[\"); break; // [\n      case 0x5d: this.onToken(RIGHT_BRACKET, \"]\"); break; // ]\n      case 0x3a: this.onToken(COLON, \":\"); break; // :\n      case 0x2c: this.onToken(COMMA, \",\"); break; // ,\n      case 0x74: this.tState = TRUE1; break; // t\n      case 0x66: this.tState = FALSE1; break; // f\n      case 0x6e: this.tState = NULL1; break; // n\n      case 0x22: this.string = \"\"; this.tState = STRING1; break; // \"\n      case 0x2d: this.negative = true; this.tState = NUMBER1; break; // -\n      case 0x30: this.magnatude = 0; this.tState = NUMBER2; break; // 0\n      default:\n        if (n > 0x30 && n < 0x40) { // 1-9\n          this.magnatude = n - 0x30; this.tState = NUMBER3;\n        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {\n          // whitespace\n        } else { this.charError(buffer, i); }\n        break;\n      }\n      break;\n    case STRING1: // After open quote\n      n = buffer[i];\n      // TODO: Handle native utf8 characters, this code assumes ASCII input\n      if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }\n      else if (n === 0x5c) { this.tState = STRING2; }\n      else if (n >= 0x20) { this.string += String.fromCharCode(n); }\n      else { this.charError(buffer, i); }\n      break;\n    case STRING2: // After backslash\n      n = buffer[i];\n      switch (n) {\n      case 0x22: this.string += \"\\\"\"; this.tState = STRING1; break;\n      case 0x5c: this.string += \"\\\\\"; this.tState = STRING1; break;\n      case 0x2f: this.string += \"\\/\"; this.tState = STRING1; break;\n      case 0x62: this.string += \"\\b\"; this.tState = STRING1; break;\n      case 0x66: this.string += \"\\f\"; this.tState = STRING1; break;\n      case 0x6e: this.string += \"\\n\"; this.tState = STRING1; break;\n      case 0x72: this.string += \"\\r\"; this.tState = STRING1; break;\n      case 0x74: this.string += \"\\t\"; this.tState = STRING1; break;\n      case 0x75: this.unicode = \"\"; this.tState = STRING3; break;\n      default: this.charError(buffer, i); break;\n      }\n      break;\n    case STRING3: case STRING4: case STRING5: case STRING6: // unicode hex codes\n      n = buffer[i];\n      // 0-9 A-F a-f\n      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {\n        this.unicode += String.fromCharCode(n);\n        if (this.tState++ === STRING6) {\n          this.string += String.fromCharCode(parseInt(this.unicode, 16));\n          this.unicode = undefined;\n          this.tState = STRING1; \n        }\n      } else {\n        this.charError(buffer, i);\n      }\n      break;\n    case NUMBER1: // after minus\n      n = buffer[i];\n      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }\n      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }\n      else { this.charError(buffer, i); }\n      break;\n    case NUMBER2: // * After initial zero\n      switch (buffer[i]) {\n      case 0x2e: // .\n        this.position = 0.1; this.tState = NUMBER4; break;\n      case 0x65: case 0x45: // e/E\n        this.exponent = 0; this.tState = NUMBER6; break;\n      default:\n        this.tState = START;\n        this.onToken(NUMBER, 0);\n        this.magnatude = undefined;\n        this.negative = undefined;\n        i--;\n        break;\n      }\n      break;\n    case NUMBER3: // * After digit (before period)\n      n = buffer[i];\n      switch (n) {\n      case 0x2e: // .\n        this.position = 0.1; this.tState = NUMBER4; break;\n      case 0x65: case 0x45: // e/E\n        this.exponent = 0; this.tState = NUMBER6; break;\n      default: \n        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }\n        else {\n          this.tState = START; \n          if (this.negative) {\n            this.magnatude = -this.magnatude;\n            this.negative = undefined;\n          }\n          this.onToken(NUMBER, this.magnatude); \n          this.magnatude = undefined;\n          i--;\n        }\n        break;\n      }\n      break;\n    case NUMBER4: // After period\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.magnatude += this.position * (n - 0x30);\n        this.position /= 10;\n        this.tState = NUMBER5; \n      } else { this.charError(buffer, i); }\n      break;\n    case NUMBER5: // * After digit (after period)\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.magnatude += this.position * (n - 0x30);\n        this.position /= 10;\n      }\n      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e\n      else {\n        this.tState = START; \n        if (this.negative) {\n          this.magnatude = -this.magnatude;\n          this.negative = undefined;\n        }\n        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); \n        this.magnatude = undefined;\n        this.position = undefined;\n        i--; \n      }\n      break;\n    case NUMBER6: // After E\n      n = buffer[i];\n      if (n === 0x2b || n === 0x2d) { // +/-\n        if (n === 0x2d) { this.negativeExponent = true; }\n        this.tState = NUMBER7;\n      }\n      else if (n >= 0x30 && n < 0x40) {\n        this.exponent = this.exponent * 10 + (n - 0x30);\n        this.tState = NUMBER8;\n      }\n      else { this.charError(buffer, i); }  \n      break;\n    case NUMBER7: // After +/-\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.exponent = this.exponent * 10 + (n - 0x30);\n        this.state = NUMBER8;\n      }\n      else { this.charError(buffer, i); }  \n      break;\n    case NUMBER8: // * After digit (after +/-)\n      n = buffer[i];\n      if (n >= 0x30 && n < 0x40) { // 0-9\n        this.exponent = this.exponent * 10 + (n - 0x30);\n      }\n      else {\n        if (this.negativeExponent) {\n          this.exponent = -this.exponent;\n          this.negativeExponent = undefined;\n        }\n        this.magnatude *= Math.pow(10, this.exponent);\n        this.exponent = undefined;\n        if (this.negative) { \n          this.magnatude = -this.magnatude;\n          this.negative = undefined;\n        }\n        this.tState = START;\n        this.onToken(NUMBER, this.magnatude);\n        this.magnatude = undefined;\n        i--; \n      }  \n      break;\n    case TRUE1: // r\n      if (buffer[i] === 0x72) { this.tState = TRUE2; }\n      else { this.charError(buffer, i); }\n      break;\n    case TRUE2: // u\n      if (buffer[i] === 0x75) { this.tState = TRUE3; }\n      else { this.charError(buffer, i); }\n      break;\n    case TRUE3: // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }\n      else { this.charError(buffer, i); }\n      break;\n    case FALSE1: // a\n      if (buffer[i] === 0x61) { this.tState = FALSE2; }\n      else { this.charError(buffer, i); }\n      break;\n    case FALSE2: // l\n      if (buffer[i] === 0x6c) { this.tState = FALSE3; }\n      else { this.charError(buffer, i); }\n      break;\n    case FALSE3: // s\n      if (buffer[i] === 0x73) { this.tState = FALSE4; }\n      else { this.charError(buffer, i); }\n      break;\n    case FALSE4: // e\n      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }\n      else { this.charError(buffer, i); }\n      break;\n    case NULL1: // u\n      if (buffer[i] === 0x75) { this.tState = NULL2; }\n      else { this.charError(buffer, i); }\n      break;\n    case NULL2: // l\n      if (buffer[i] === 0x6c) { this.tState = NULL3; }\n      else { this.charError(buffer, i); }\n      break;\n    case NULL3: // l\n      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }\n      else { this.charError(buffer, i); }\n      break;\n    }\n  }\n};\nproto.onToken = function (token, value) {\n  // Override this to get events\n};\n\nproto.parseError = function (token, value) {\n  this.onError(new Error(\"Unexpected \" + toknam(token) + (value ? (\"(\" + JSON.stringify(value) + \")\") : \"\") + \" in state \" + toknam(this.state)));\n};\nproto.onError = function (err) { throw err; };\nproto.push = function () {\n  this.stack.push({value: this.value, key: this.key, mode: this.mode});\n};\nproto.pop = function () {\n  var value = this.value;\n  var parent = this.stack.pop();\n  this.value = parent.value;\n  this.key = parent.key;\n  this.mode = parent.mode;\n  this.emit(value);\n  if (!this.mode) { this.state = VALUE; }\n};\nproto.emit = function (value) {\n  if (this.mode) { this.state = COMMA; }\n  this.onValue(value);\n};\nproto.onValue = function (value) {\n  // Override me\n};  \nproto.onToken = function (token, value) {\n  //console.log(\"OnToken: state=%s token=%s %s\", toknam(this.state), toknam(token), value?JSON.stringify(value):\"\");\n  switch (this.state) {\n  case VALUE:\n    switch (token) {\n    case STRING: case NUMBER: case TRUE: case FALSE: case NULL:\n      if (this.value) {\n        this.value[this.key] = value;\n      }\n      this.emit(value);\n    break;  \n    case LEFT_BRACE:\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = {};\n      } else {\n        this.value = {};\n      }\n      this.key = undefined;\n      this.state = KEY;\n      this.mode = OBJECT;\n      break;\n    case LEFT_BRACKET:\n      this.push();\n      if (this.value) {\n        this.value = this.value[this.key] = [];\n      } else {\n        this.value = [];\n      }\n      this.key = 0;\n      this.mode = ARRAY;\n      this.state = VALUE;\n      break;\n    case RIGHT_BRACE:\n      if (this.mode === OBJECT) {\n        this.pop();\n      } else {\n        this.parseError(token, value);\n      }\n      break;\n    case RIGHT_BRACKET:\n      if (this.mode === ARRAY) {\n        this.pop();\n      } else {\n        this.parseError(token, value);\n      }\n      break;\n    default:\n      this.parseError(token, value); break;\n    }\n    break;\n  case KEY:\n    if (token === STRING) {\n      this.key = value;\n      this.state = COLON;\n    } else if (token === RIGHT_BRACE) {\n      this.pop();\n    } else {\n      this.parseError(token, value);\n    }\n    break;\n  case COLON:\n    if (token === COLON) { this.state = VALUE; }\n    else { this.parseError(token, value); }\n    break;\n  case COMMA:\n    if (token === COMMA) { \n      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }\n      else if (this.mode === OBJECT) { this.state = KEY; }\n\n    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {\n      this.pop();\n    } else {\n      this.parseError(token, value);\n    }\n    break;\n  default:\n    this.parseError(token, value);\n  }\n};\n\nmodule.exports = Parser;\n\n//@ sourceURL=/node_modules/JSONStream/node_modules/jsonparse/jsonparse.js"
));

require.define("stream",Function(['require','module','exports','__dirname','__filename','process'],"var events = require('events');\nvar util = require('util');\n\nfunction Stream() {\n  events.EventEmitter.call(this);\n}\nutil.inherits(Stream, events.EventEmitter);\nmodule.exports = Stream;\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once, and\n  // only when all sources have ended.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    dest._pipeCount = dest._pipeCount || 0;\n    dest._pipeCount++;\n\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest._pipeCount--;\n\n    // remove the listeners\n    cleanup();\n\n    if (dest._pipeCount > 0) {\n      // waiting for other incoming streams to end.\n      return;\n    }\n\n    dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (this.listeners('error').length === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('end', cleanup);\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('end', cleanup);\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n//@ sourceURL=stream"
));

require.define("events",Function(['require','module','exports','__dirname','__filename','process'],"if (!process.EventEmitter) process.EventEmitter = function () {};\n\nvar EventEmitter = exports.EventEmitter = process.EventEmitter;\nvar isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    }\n;\n\n// By default EventEmitters will print a warning if more than\n// 10 listeners are added to it. This is a useful default which\n// helps finding memory leaks.\n//\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nvar defaultMaxListeners = 10;\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!this._events) this._events = {};\n  this._events.maxListeners = n;\n};\n\n\nEventEmitter.prototype.emit = function(type) {\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events || !this._events.error ||\n        (isArray(this._events.error) && !this._events.error.length))\n    {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n      return false;\n    }\n  }\n\n  if (!this._events) return false;\n  var handler = this._events[type];\n  if (!handler) return false;\n\n  if (typeof handler == 'function') {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        var args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n    return true;\n\n  } else if (isArray(handler)) {\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    var listeners = handler.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n      listeners[i].apply(this, args);\n    }\n    return true;\n\n  } else {\n    return false;\n  }\n};\n\n// EventEmitter is defined in src/node_events.cc\n// EventEmitter.prototype.emit() is also defined there.\nEventEmitter.prototype.addListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('addListener only takes instances of Function');\n  }\n\n  if (!this._events) this._events = {};\n\n  // To avoid recursion in the case that type == \"newListeners\"! Before\n  // adding it to the listeners, first emit \"newListeners\".\n  this.emit('newListener', type, listener);\n\n  if (!this._events[type]) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  } else if (isArray(this._events[type])) {\n\n    // Check for listener leak\n    if (!this._events[type].warned) {\n      var m;\n      if (this._events.maxListeners !== undefined) {\n        m = this._events.maxListeners;\n      } else {\n        m = defaultMaxListeners;\n      }\n\n      if (m && m > 0 && this._events[type].length > m) {\n        this._events[type].warned = true;\n        console.error('(node) warning: possible EventEmitter memory ' +\n                      'leak detected. %d listeners added. ' +\n                      'Use emitter.setMaxListeners() to increase limit.',\n                      this._events[type].length);\n        console.trace();\n      }\n    }\n\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  } else {\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  var self = this;\n  self.on(type, function g() {\n    self.removeListener(type, g);\n    listener.apply(this, arguments);\n  });\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  if ('function' !== typeof listener) {\n    throw new Error('removeListener only takes instances of Function');\n  }\n\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (!this._events || !this._events[type]) return this;\n\n  var list = this._events[type];\n\n  if (isArray(list)) {\n    var i = list.indexOf(listener);\n    if (i < 0) return this;\n    list.splice(i, 1);\n    if (list.length == 0)\n      delete this._events[type];\n  } else if (this._events[type] === listener) {\n    delete this._events[type];\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  // does not use listeners(), so no side effect of creating _events[type]\n  if (type && this._events && this._events[type]) this._events[type] = null;\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  if (!this._events) this._events = {};\n  if (!this._events[type]) this._events[type] = [];\n  if (!isArray(this._events[type])) {\n    this._events[type] = [this._events[type]];\n  }\n  return this._events[type];\n};\n\n//@ sourceURL=events"
));

require.define("util",Function(['require','module','exports','__dirname','__filename','process'],"var events = require('events');\n\nexports.print = function () {};\nexports.puts = function () {};\nexports.debug = function() {};\n\nexports.inspect = function(obj, showHidden, depth, colors) {\n  var seen = [];\n\n  var stylize = function(str, styleType) {\n    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n    var styles =\n        { 'bold' : [1, 22],\n          'italic' : [3, 23],\n          'underline' : [4, 24],\n          'inverse' : [7, 27],\n          'white' : [37, 39],\n          'grey' : [90, 39],\n          'black' : [30, 39],\n          'blue' : [34, 39],\n          'cyan' : [36, 39],\n          'green' : [32, 39],\n          'magenta' : [35, 39],\n          'red' : [31, 39],\n          'yellow' : [33, 39] };\n\n    var style =\n        { 'special': 'cyan',\n          'number': 'blue',\n          'boolean': 'yellow',\n          'undefined': 'grey',\n          'null': 'bold',\n          'string': 'green',\n          'date': 'magenta',\n          // \"name\": intentionally not styling\n          'regexp': 'red' }[styleType];\n\n    if (style) {\n      return '\\033[' + styles[style][0] + 'm' + str +\n             '\\033[' + styles[style][1] + 'm';\n    } else {\n      return str;\n    }\n  };\n  if (! colors) {\n    stylize = function(str, styleType) { return str; };\n  }\n\n  function format(value, recurseTimes) {\n    // Provide a hook for user-specified inspect functions.\n    // Check that value is an object with an inspect function on it\n    if (value && typeof value.inspect === 'function' &&\n        // Filter out the util module, it's inspect function is special\n        value !== exports &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      return value.inspect(recurseTimes);\n    }\n\n    // Primitive types cannot have properties\n    switch (typeof value) {\n      case 'undefined':\n        return stylize('undefined', 'undefined');\n\n      case 'string':\n        var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                                 .replace(/'/g, \"\\\\'\")\n                                                 .replace(/\\\\\"/g, '\"') + '\\'';\n        return stylize(simple, 'string');\n\n      case 'number':\n        return stylize('' + value, 'number');\n\n      case 'boolean':\n        return stylize('' + value, 'boolean');\n    }\n    // For some reason typeof null is \"object\", so special case here.\n    if (value === null) {\n      return stylize('null', 'null');\n    }\n\n    // Look up the keys of the object.\n    var visible_keys = Object_keys(value);\n    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;\n\n    // Functions without properties can be shortcutted.\n    if (typeof value === 'function' && keys.length === 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        var name = value.name ? ': ' + value.name : '';\n        return stylize('[Function' + name + ']', 'special');\n      }\n    }\n\n    // Dates without properties can be shortcutted\n    if (isDate(value) && keys.length === 0) {\n      return stylize(value.toUTCString(), 'date');\n    }\n\n    var base, type, braces;\n    // Determine the object type\n    if (isArray(value)) {\n      type = 'Array';\n      braces = ['[', ']'];\n    } else {\n      type = 'Object';\n      braces = ['{', '}'];\n    }\n\n    // Make functions say that they are functions\n    if (typeof value === 'function') {\n      var n = value.name ? ': ' + value.name : '';\n      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';\n    } else {\n      base = '';\n    }\n\n    // Make dates with properties first say the date\n    if (isDate(value)) {\n      base = ' ' + value.toUTCString();\n    }\n\n    if (keys.length === 0) {\n      return braces[0] + base + braces[1];\n    }\n\n    if (recurseTimes < 0) {\n      if (isRegExp(value)) {\n        return stylize('' + value, 'regexp');\n      } else {\n        return stylize('[Object]', 'special');\n      }\n    }\n\n    seen.push(value);\n\n    var output = keys.map(function(key) {\n      var name, str;\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Getter/Setter]', 'special');\n          } else {\n            str = stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = stylize('[Setter]', 'special');\n          }\n        }\n      }\n      if (visible_keys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n      if (!str) {\n        if (seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = format(value[key]);\n          } else {\n            str = format(value[key], recurseTimes - 1);\n          }\n          if (str.indexOf('\\n') > -1) {\n            if (isArray(value)) {\n              str = str.split('\\n').map(function(line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function(line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = stylize('[Circular]', 'special');\n        }\n      }\n      if (typeof name === 'undefined') {\n        if (type === 'Array' && key.match(/^\\d+$/)) {\n          return str;\n        }\n        name = JSON.stringify('' + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\")\n                     .replace(/\\\\\"/g, '\"')\n                     .replace(/(^\"|\"$)/g, \"'\");\n          name = stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    });\n\n    seen.pop();\n\n    var numLinesEst = 0;\n    var length = output.reduce(function(prev, cur) {\n      numLinesEst++;\n      if (cur.indexOf('\\n') >= 0) numLinesEst++;\n      return prev + cur.length + 1;\n    }, 0);\n\n    if (length > 50) {\n      output = braces[0] +\n               (base === '' ? '' : base + '\\n ') +\n               ' ' +\n               output.join(',\\n  ') +\n               ' ' +\n               braces[1];\n\n    } else {\n      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    return output;\n  }\n  return format(obj, (typeof depth === 'undefined' ? 2 : depth));\n};\n\n\nfunction isArray(ar) {\n  return ar instanceof Array ||\n         Array.isArray(ar) ||\n         (ar && ar !== Object.prototype && isArray(ar.__proto__));\n}\n\n\nfunction isRegExp(re) {\n  return re instanceof RegExp ||\n    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');\n}\n\n\nfunction isDate(d) {\n  if (d instanceof Date) return true;\n  if (typeof d !== 'object') return false;\n  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);\n  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);\n  return JSON.stringify(proto) === JSON.stringify(properties);\n}\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\nexports.log = function (msg) {};\n\nexports.pump = null;\n\nvar Object_keys = Object.keys || function (obj) {\n    var res = [];\n    for (var key in obj) res.push(key);\n    return res;\n};\n\nvar Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {\n    var res = [];\n    for (var key in obj) {\n        if (Object.hasOwnProperty.call(obj, key)) res.push(key);\n    }\n    return res;\n};\n\nvar Object_create = Object.create || function (prototype, properties) {\n    // from es5-shim\n    var object;\n    if (prototype === null) {\n        object = { '__proto__' : null };\n    }\n    else {\n        if (typeof prototype !== 'object') {\n            throw new TypeError(\n                'typeof prototype[' + (typeof prototype) + '] != \\'object\\''\n            );\n        }\n        var Type = function () {};\n        Type.prototype = prototype;\n        object = new Type();\n        object.__proto__ = prototype;\n    }\n    if (typeof properties !== 'undefined' && Object.defineProperties) {\n        Object.defineProperties(object, properties);\n    }\n    return object;\n};\n\nexports.inherits = function(ctor, superCtor) {\n  ctor.super_ = superCtor;\n  ctor.prototype = Object_create(superCtor.prototype, {\n    constructor: {\n      value: ctor,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n};\n\n//@ sourceURL=util"
));

require.define("/node_modules/request/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"./main\"}\n//@ sourceURL=/node_modules/request/package.json"
));

require.define("/node_modules/request/main.js",Function(['require','module','exports','__dirname','__filename','process'],"// Copyright 2010-2011 Mikeal Rogers\n//\n//    Licensed under the Apache License, Version 2.0 (the \"License\");\n//    you may not use this file except in compliance with the License.\n//    You may obtain a copy of the License at\n//\n//        http://www.apache.org/licenses/LICENSE-2.0\n//\n//    Unless required by applicable law or agreed to in writing, software\n//    distributed under the License is distributed on an \"AS IS\" BASIS,\n//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n//    See the License for the specific language governing permissions and\n//    limitations under the License.\n\nvar http = require('http')\n  , https = false\n  , tls = false\n  , url = require('url')\n  , util = require('util')\n  , stream = require('stream')\n  , qs = require('querystring')\n  , mimetypes = require('./mimetypes')\n  , oauth = require('./oauth')\n  , uuid = require('./uuid')\n  , ForeverAgent = require('./forever')\n  , Cookie = require('./vendor/cookie')\n  , CookieJar = require('./vendor/cookie/jar')\n  , cookieJar = new CookieJar\n  ;\n  \nif (process.logging) {\n  var log = process.logging('request')\n}\n\ntry {\n  https = require('https')\n} catch (e) {}\n\ntry {\n  tls = require('tls')\n} catch (e) {}\n\nfunction toBase64 (str) {\n  return (new Buffer(str || \"\", \"ascii\")).toString(\"base64\")\n}\n\n// Hacky fix for pre-0.4.4 https\nif (https && !https.Agent) {\n  https.Agent = function (options) {\n    http.Agent.call(this, options)\n  }\n  util.inherits(https.Agent, http.Agent)\n  https.Agent.prototype._getConnection = function(host, port, cb) {\n    var s = tls.connect(port, host, this.options, function() {\n      // do other checks here?\n      if (cb) cb()\n    })\n    return s\n  }\n}\n\nfunction isReadStream (rs) {\n  if (rs.readable && rs.path && rs.mode) {\n    return true\n  }\n}\n\nfunction copy (obj) {\n  var o = {}\n  for (var i in obj) o[i] = obj[i]\n  return o\n}\n\nvar isUrl = /^https?:/\n\nvar globalPool = {}\n\nfunction Request (options) {\n  stream.Stream.call(this)\n  this.readable = true\n  this.writable = true\n\n  if (typeof options === 'string') {\n    options = {uri:options}\n  }\n\n  for (var i in options) {\n    this[i] = options[i]\n  }\n  if (!this.pool) this.pool = globalPool\n  this.dests = []\n  this.__isRequestRequest = true\n}\nutil.inherits(Request, stream.Stream)\nRequest.prototype.getAgent = function (host, port) {\n  if (!this.pool[host+':'+port]) {\n    this.pool[host+':'+port] = new this.httpModule.Agent({host:host, port:port})\n  }\n  return this.pool[host+':'+port]\n}\nRequest.prototype.request = function () {\n  var self = this\n\n  // Protect against double callback\n  if (!self._callback && self.callback) {\n    self._callback = self.callback\n    self.callback = function () {\n      if (self._callbackCalled) return // Print a warning maybe?\n      self._callback.apply(self, arguments)\n      self._callbackCalled = true\n    }\n  }\n\n  if (self.url) {\n    // People use this property instead all the time so why not just support it.\n    self.uri = self.url\n    delete self.url\n  }\n\n  if (!self.uri) {\n    throw new Error(\"options.uri is a required argument\")\n  } else {\n    if (typeof self.uri == \"string\") self.uri = url.parse(self.uri)\n  }\n  if (self.proxy) {\n    if (typeof self.proxy == 'string') self.proxy = url.parse(self.proxy)\n  }\n\n  self._redirectsFollowed = self._redirectsFollowed || 0\n  self.maxRedirects = (self.maxRedirects !== undefined) ? self.maxRedirects : 10\n  self.followRedirect = (self.followRedirect !== undefined) ? self.followRedirect : true\n  if (self.followRedirect)\n    self.redirects = self.redirects || []\n\n  self.headers = self.headers ? copy(self.headers) : {}\n\n  var setHost = false\n  if (!self.headers.host) {\n    self.headers.host = self.uri.hostname\n    if (self.uri.port) {\n      if ( !(self.uri.port === 80 && self.uri.protocol === 'http:') &&\n           !(self.uri.port === 443 && self.uri.protocol === 'https:') )\n      self.headers.host += (':'+self.uri.port)\n    }\n    setHost = true\n  }\n\n  if (self.jar === false) {\n    // disable cookies\n    var cookies = false;\n    self._disableCookies = true;\n  } else if (self.jar) {\n    // fetch cookie from the user defined cookie jar\n    var cookies = self.jar.get({ url: self.uri.href })\n  } else {\n    // fetch cookie from the global cookie jar\n    var cookies = cookieJar.get({ url: self.uri.href })\n  }\n  if (cookies) {\n    var cookieString = cookies.map(function (c) {\n      return c.name + \"=\" + c.value;\n    }).join(\"; \");\n    \n    self.headers.Cookie = cookieString;\n  }\n\n  if (!self.uri.pathname) {self.uri.pathname = '/'}\n  if (!self.uri.port) {\n    if (self.uri.protocol == 'http:') {self.uri.port = 80}\n    else if (self.uri.protocol == 'https:') {self.uri.port = 443}\n  }\n\n  if (self.proxy) {\n    self.port = self.proxy.port\n    self.host = self.proxy.hostname\n  } else {\n    self.port = self.uri.port\n    self.host = self.uri.hostname\n  }\n\n  if (self.onResponse === true) {\n    self.onResponse = self.callback\n    delete self.callback\n  }\n\n  var clientErrorHandler = function (error) {\n    if (setHost) delete self.headers.host\n    if (self.req._reusedSocket && error.code === 'ECONNRESET') {\n      self.agent = {addRequest: ForeverAgent.prototype.addRequestNoreuse.bind(self.agent)}\n      self.start()\n      self.req.end()\n      return\n    }\n    if (self.timeout && self.timeoutTimer) clearTimeout(self.timeoutTimer)\n    self.emit('error', error)\n  }\n  if (self.onResponse) self.on('error', function (e) {self.onResponse(e)})\n  if (self.callback) self.on('error', function (e) {self.callback(e)})\n\n  if (self.form) {\n    self.headers['content-type'] = 'application/x-www-form-urlencoded; charset=utf-8'\n    self.body = qs.stringify(self.form).toString('utf8')\n  }\n\n  if (self.oauth) {\n    var form\n    if (self.headers['content-type'] && \n        self.headers['content-type'].slice(0, 'application/x-www-form-urlencoded'.length) ===\n          'application/x-www-form-urlencoded' \n       ) {\n      form = qs.parse(self.body)\n    } \n    if (self.uri.query) {\n      form = qs.parse(self.uri.query)\n    } \n    if (!form) form = {}\n    var oa = {}\n    for (var i in form) oa[i] = form[i]\n    for (var i in self.oauth) oa['oauth_'+i] = self.oauth[i]\n    if (!oa.oauth_version) oa.oauth_version = '1.0'\n    if (!oa.oauth_timestamp) oa.oauth_timestamp = Math.floor( (new Date()).getTime() / 1000 ).toString()\n    if (!oa.oauth_nonce) oa.oauth_nonce = uuid().replace(/-/g, '')\n    \n    oa.oauth_signature_method = 'HMAC-SHA1'\n    \n    var consumer_secret = oa.oauth_consumer_secret\n    delete oa.oauth_consumer_secret\n    var token_secret = oa.oauth_token_secret\n    delete oa.oauth_token_secret\n    \n    var baseurl = self.uri.protocol + '//' + self.uri.host + self.uri.pathname\n    var signature = oauth.hmacsign(self.method, baseurl, oa, consumer_secret, token_secret)\n    \n    // oa.oauth_signature = signature\n    for (var i in form) {\n      if ( i.slice(0, 'oauth_') in self.oauth) {\n        // skip \n      } else {\n        delete oa['oauth_'+i]\n      }\n    }\n    self.headers.authorization = \n      'OAuth '+Object.keys(oa).sort().map(function (i) {return i+'=\"'+oauth.rfc3986(oa[i])+'\"'}).join(',')\n    self.headers.authorization += ',oauth_signature=\"'+oauth.rfc3986(signature)+'\"'  \n  }\n\n  if (self.uri.auth && !self.headers.authorization) {\n    self.headers.authorization = \"Basic \" + toBase64(self.uri.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))\n  }\n  if (self.proxy && self.proxy.auth && !self.headers['proxy-authorization']) {\n    self.headers['proxy-authorization'] = \"Basic \" + toBase64(self.proxy.auth.split(':').map(function(item){ return qs.unescape(item)}).join(':'))\n  }\n\n  if (self.uri.path) {\n    self.path = self.uri.path\n  } else {\n    self.path = self.uri.pathname + (self.uri.search || \"\")\n  }\n\n  if (self.path.length === 0) self.path = '/'\n\n  if (self.proxy) self.path = (self.uri.protocol + '//' + self.uri.host + self.path)\n\n  if (self.json) {\n    self.headers['content-type'] = 'application/json'\n    if (typeof self.json === 'boolean') {\n      if (typeof self.body === 'object') self.body = JSON.stringify(self.body)\n    } else {\n      self.body = JSON.stringify(self.json)\n    }\n\n  } else if (self.multipart) {\n    self.body = []\n\n    if (!self.headers['content-type']) {\n      self.headers['content-type'] = 'multipart/related;boundary=\"frontier\"';\n    } else {\n      self.headers['content-type'] = self.headers['content-type'].split(';')[0] + ';boundary=\"frontier\"';\n    }\n\n    if (!self.multipart.forEach) throw new Error('Argument error, options.multipart.')\n\n    self.multipart.forEach(function (part) {\n      var body = part.body\n      if(!body) throw Error('Body attribute missing in multipart.')\n      delete part.body\n      var preamble = '--frontier\\r\\n'\n      Object.keys(part).forEach(function(key){\n        preamble += key + ': ' + part[key] + '\\r\\n'\n      })\n      preamble += '\\r\\n'\n      self.body.push(new Buffer(preamble))\n      self.body.push(new Buffer(body))\n      self.body.push(new Buffer('\\r\\n'))\n    })\n    self.body.push(new Buffer('--frontier--'))\n  }\n\n  if (self.body) {\n    var length = 0\n    if (!Buffer.isBuffer(self.body)) {\n      if (Array.isArray(self.body)) {\n        for (var i = 0; i < self.body.length; i++) {\n          length += self.body[i].length\n        }\n      } else {\n        self.body = new Buffer(self.body)\n        length = self.body.length\n      }\n    } else {\n      length = self.body.length\n    }\n    if (length) {\n      self.headers['content-length'] = length\n    } else {\n      throw new Error('Argument error, options.body.')\n    }\n  }\n\n  var protocol = self.proxy ? self.proxy.protocol : self.uri.protocol\n    , defaultModules = {'http:':http, 'https:':https}\n    , httpModules = self.httpModules || {}\n    ;\n  self.httpModule = httpModules[protocol] || defaultModules[protocol]\n\n  if (!self.httpModule) throw new Error(\"Invalid protocol\")\n\n  if (self.pool === false) {\n    self.agent = false\n  } else {\n    if (self.maxSockets) {\n      // Don't use our pooling if node has the refactored client\n      self.agent = self.agent || self.httpModule.globalAgent || self.getAgent(self.host, self.port)\n      self.agent.maxSockets = self.maxSockets\n    }\n    if (self.pool.maxSockets) {\n      // Don't use our pooling if node has the refactored client\n      self.agent = self.agent || self.httpModule.globalAgent || self.getAgent(self.host, self.port)\n      self.agent.maxSockets = self.pool.maxSockets\n    }\n  }\n\n  self.start = function () {\n    self._started = true\n    self.method = self.method || 'GET'\n    self.href = self.uri.href\n    if (log) log('%method %href', self)\n    self.req = self.httpModule.request(self, function (response) {\n      self.response = response\n      response.request = self\n\n      if (self.httpModule === https &&\n          self.strictSSL &&\n          !response.client.authorized) {\n        var sslErr = response.client.authorizationError\n        self.emit('error', new Error('SSL Error: '+ sslErr))\n        return\n      }\n\n      if (setHost) delete self.headers.host\n      if (self.timeout && self.timeoutTimer) clearTimeout(self.timeoutTimer)\n      \n      if (response.headers['set-cookie'] && (!self._disableCookies)) {\n        response.headers['set-cookie'].forEach(function(cookie) {\n          if (self.jar) self.jar.add(new Cookie(cookie))\n          else cookieJar.add(new Cookie(cookie))\n        })\n      }\n\n      if (response.statusCode >= 300 &&\n          response.statusCode < 400  &&\n          self.followRedirect     &&\n          self.method !== 'PUT' &&\n          self.method !== 'POST' &&\n          response.headers.location) {\n        if (self._redirectsFollowed >= self.maxRedirects) {\n          self.emit('error', new Error(\"Exceeded maxRedirects. Probably stuck in a redirect loop.\"))\n          return\n        }\n        self._redirectsFollowed += 1\n\n        if (!isUrl.test(response.headers.location)) {\n          response.headers.location = url.resolve(self.uri.href, response.headers.location)\n        }\n        self.uri = response.headers.location\n        self.redirects.push(\n          { statusCode : response.statusCode\n          , redirectUri: response.headers.location \n          }\n        )\n        delete self.req\n        delete self.agent\n        delete self._started\n        if (self.headers) {\n          delete self.headers.host\n        }\n        if (log) log('Redirect to %uri', self)\n        request(self, self.callback)\n        return // Ignore the rest of the response\n      } else {\n        self._redirectsFollowed = self._redirectsFollowed || 0\n        // Be a good stream and emit end when the response is finished.\n        // Hack to emit end on close because of a core bug that never fires end\n        response.on('close', function () {\n          if (!self._ended) self.response.emit('end')\n        })\n\n        if (self.encoding) {\n          if (self.dests.length !== 0) {\n            console.error(\"Ingoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.\")\n          } else {\n            response.setEncoding(self.encoding)\n          }\n        }\n\n        self.pipeDest = function (dest) {\n          if (dest.headers) {\n            dest.headers['content-type'] = response.headers['content-type']\n            if (response.headers['content-length']) {\n              dest.headers['content-length'] = response.headers['content-length']\n            }\n          }\n          if (dest.setHeader) {\n            for (var i in response.headers) {\n              dest.setHeader(i, response.headers[i])\n            }\n            dest.statusCode = response.statusCode\n          }\n          if (self.pipefilter) self.pipefilter(response, dest)\n        }\n\n        self.dests.forEach(function (dest) {\n          self.pipeDest(dest)\n        })\n\n        response.on(\"data\", function (chunk) {\n          self._destdata = true\n          self.emit(\"data\", chunk)\n        })\n        response.on(\"end\", function (chunk) {\n          self._ended = true\n          self.emit(\"end\", chunk)\n        })\n        response.on(\"close\", function () {self.emit(\"close\")})\n\n        self.emit('response', response)\n\n        if (self.onResponse) {\n          self.onResponse(null, response)\n        }\n        if (self.callback) {\n          var buffer = []\n          var bodyLen = 0\n          self.on(\"data\", function (chunk) {\n            buffer.push(chunk)\n            bodyLen += chunk.length\n          })\n          self.on(\"end\", function () {\n            if (buffer.length && Buffer.isBuffer(buffer[0])) {\n              var body = new Buffer(bodyLen)\n              var i = 0\n              buffer.forEach(function (chunk) {\n                chunk.copy(body, i, 0, chunk.length)\n                i += chunk.length\n              })\n              if (self.encoding === null) {\n                response.body = body\n              } else {\n                response.body = body.toString()\n              }\n            } else if (buffer.length) {\n              response.body = buffer.join('')\n            }\n\n            if (self.json) {\n              try {\n                response.body = JSON.parse(response.body)\n              } catch (e) {}\n            }\n\n            self.callback(null, response, response.body)\n          })\n        }\n      }\n    })\n\n    if (self.timeout && !self.timeoutTimer) {\n      self.timeoutTimer = setTimeout(function() {\n        self.req.abort()\n        var e = new Error(\"ETIMEDOUT\")\n        e.code = \"ETIMEDOUT\"\n        self.emit(\"error\", e)\n      }, self.timeout)\n    }\n    \n    self.req.on('error', clientErrorHandler)\n  }\n\n  self.once('pipe', function (src) {\n    if (self.ntick) throw new Error(\"You cannot pipe to this stream after the first nextTick() after creation of the request stream.\")\n    self.src = src\n    if (isReadStream(src)) {\n      if (!self.headers['content-type'] && !self.headers['Content-Type'])\n        self.headers['content-type'] = mimetypes.lookup(src.path.slice(src.path.lastIndexOf('.')+1))\n    } else {\n      if (src.headers) {\n        for (var i in src.headers) {\n          if (!self.headers[i]) {\n            self.headers[i] = src.headers[i]\n          }\n        }\n      }\n      if (src.method && !self.method) {\n        self.method = src.method\n      }\n    }\n\n    self.on('pipe', function () {\n      console.error(\"You have already piped to this stream. Pipeing twice is likely to break the request.\")\n    })\n  })\n\n  process.nextTick(function () {\n    if (self.body) {\n      if (Array.isArray(self.body)) {\n        self.body.forEach(function(part) {\n          self.write(part)\n        })\n      } else {\n        self.write(self.body)\n      }\n      self.end()\n    } else if (self.requestBodyStream) {\n      console.warn(\"options.requestBodyStream is deprecated, please pass the request object to stream.pipe.\")\n      self.requestBodyStream.pipe(self)\n    } else if (!self.src) {\n      self.headers['content-length'] = 0\n      self.end()\n    }\n    self.ntick = true\n  })\n}\nRequest.prototype.pipe = function (dest) {\n  if (this.response) {\n    if (this._destdata) {\n      throw new Error(\"You cannot pipe after data has been emitted from the response.\")\n    } else if (this._ended) {\n      throw new Error(\"You cannot pipe after the response has been ended.\")\n    } else {\n      stream.Stream.prototype.pipe.call(this, dest)\n      this.pipeDest(dest)\n      return dest\n    }\n  } else {\n    this.dests.push(dest)\n    stream.Stream.prototype.pipe.call(this, dest)\n    return dest\n  }\n}\nRequest.prototype.write = function () {\n  if (!this._started) this.start()\n  if (!this.req) throw new Error(\"This request has been piped before http.request() was called.\")\n  this.req.write.apply(this.req, arguments)\n}\nRequest.prototype.end = function () {\n  if (!this._started) this.start()\n  if (!this.req) throw new Error(\"This request has been piped before http.request() was called.\")\n  this.req.end.apply(this.req, arguments)\n}\nRequest.prototype.pause = function () {\n  if (!this.response) throw new Error(\"This request has been piped before http.request() was called.\")\n  this.response.pause.apply(this.response, arguments)\n}\nRequest.prototype.resume = function () {\n  if (!this.response) throw new Error(\"This request has been piped before http.request() was called.\")\n  this.response.resume.apply(this.response, arguments)\n}\n\nfunction request (options, callback) {\n  if (typeof options === 'string') options = {uri:options}\n  if (callback) options.callback = callback\n  var r = new Request(options)\n  r.request()\n  return r\n}\n\nmodule.exports = request\n\nrequest.defaults = function (options) {\n  var def = function (method) {\n    var d = function (opts, callback) {\n      if (typeof opts === 'string') opts = {uri:opts}\n      for (var i in options) {\n        if (opts[i] === undefined) opts[i] = options[i]\n      }\n      return method(opts, callback)\n    }\n    return d\n  }\n  var de = def(request)\n  de.get = def(request.get)\n  de.post = def(request.post)\n  de.put = def(request.put)\n  de.head = def(request.head)\n  de.del = def(request.del)\n  de.cookie = def(request.cookie)\n  de.jar = def(request.jar)\n  return de\n}\n\nrequest.forever = function (agentOptions, optionsArg) {\n  var options = {}\n  if (agentOptions) {\n    for (option in optionsArg) {\n      options[option] = optionsArg[option]\n    }\n  }\n  options.agent = new ForeverAgent(agentOptions)\n  return request.defaults(options)\n}\n\nrequest.get = request\nrequest.post = function (options, callback) {\n  if (typeof options === 'string') options = {uri:options}\n  options.method = 'POST'\n  return request(options, callback)\n}\nrequest.put = function (options, callback) {\n  if (typeof options === 'string') options = {uri:options}\n  options.method = 'PUT'\n  return request(options, callback)\n}\nrequest.head = function (options, callback) {\n  if (typeof options === 'string') options = {uri:options}\n  options.method = 'HEAD'\n  if (options.body || options.requestBodyStream || options.json || options.multipart) {\n    throw new Error(\"HTTP HEAD requests MUST NOT include a request body.\")\n  }\n  return request(options, callback)\n}\nrequest.del = function (options, callback) {\n  if (typeof options === 'string') options = {uri:options}\n  options.method = 'DELETE'\n  return request(options, callback)\n}\nrequest.jar = function () {\n  return new CookieJar\n}\nrequest.cookie = function (str) {\n  if (typeof str !== 'string') throw new Error(\"The cookie function only accepts STRING as param\")\n  return new Cookie(str)\n}\n\n//@ sourceURL=/node_modules/request/main.js"
));

require.define("http",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"http-browserify\")\n//@ sourceURL=http"
));

require.define("/node_modules/http-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {\"main\":\"index.js\",\"browserify\":\"index.js\"}\n//@ sourceURL=/node_modules/http-browserify/package.json"
));

require.define("/node_modules/http-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var http = module.exports;\nvar EventEmitter = require('events').EventEmitter;\nvar Request = require('./lib/request');\n\nhttp.request = function (params, cb) {\n    if (!params) params = {};\n    if (!params.host) params.host = window.location.host.split(':')[0];\n    if (!params.port) params.port = window.location.port;\n    \n    var req = new Request(new xhrHttp, params);\n    if (cb) req.on('response', cb);\n    return req;\n};\n\nhttp.get = function (params, cb) {\n    params.method = 'GET';\n    var req = http.request(params, cb);\n    req.end();\n    return req;\n};\n\nhttp.Agent = function () {};\nhttp.Agent.defaultMaxSockets = 4;\n\nvar xhrHttp = (function () {\n    if (typeof window === 'undefined') {\n        throw new Error('no window object present');\n    }\n    else if (window.XMLHttpRequest) {\n        return window.XMLHttpRequest;\n    }\n    else if (window.ActiveXObject) {\n        var axs = [\n            'Msxml2.XMLHTTP.6.0',\n            'Msxml2.XMLHTTP.3.0',\n            'Microsoft.XMLHTTP'\n        ];\n        for (var i = 0; i < axs.length; i++) {\n            try {\n                var ax = new(window.ActiveXObject)(axs[i]);\n                return function () {\n                    if (ax) {\n                        var ax_ = ax;\n                        ax = null;\n                        return ax_;\n                    }\n                    else {\n                        return new(window.ActiveXObject)(axs[i]);\n                    }\n                };\n            }\n            catch (e) {}\n        }\n        throw new Error('ajax not supported in this browser')\n    }\n    else {\n        throw new Error('ajax not supported in this browser');\n    }\n})();\n\n//@ sourceURL=/node_modules/http-browserify/index.js"
));

require.define("/node_modules/http-browserify/lib/request.js",Function(['require','module','exports','__dirname','__filename','process'],"var EventEmitter = require('events').EventEmitter;\nvar Response = require('./response');\nvar concatStream = require('concat-stream')\n\nvar Request = module.exports = function (xhr, params) {\n    var self = this;\n    self.xhr = xhr;\n    self.body = concatStream()\n    \n    var uri = params.host + ':' + params.port + (params.path || '/');\n    \n    xhr.open(\n        params.method || 'GET',\n        (params.scheme || 'http') + '://' + uri,\n        true\n    );\n    \n    if (params.headers) {\n        Object.keys(params.headers).forEach(function (key) {\n            if (!self.isSafeRequestHeader(key)) return;\n            var value = params.headers[key];\n            if (Array.isArray(value)) {\n                value.forEach(function (v) {\n                    xhr.setRequestHeader(key, v);\n                });\n            }\n            else xhr.setRequestHeader(key, value)\n        });\n    }\n    \n    var res = new Response;\n    res.on('ready', function () {\n        self.emit('response', res);\n    });\n    \n    xhr.onreadystatechange = function () {\n        res.handle(xhr);\n    };\n};\n\nRequest.prototype = new EventEmitter;\n\nRequest.prototype.setHeader = function (key, value) {\n    if ((Array.isArray && Array.isArray(value))\n    || value instanceof Array) {\n        for (var i = 0; i < value.length; i++) {\n            this.xhr.setRequestHeader(key, value[i]);\n        }\n    }\n    else {\n        this.xhr.setRequestHeader(key, value);\n    }\n};\n\nRequest.prototype.write = function (s) {\n    this.body.write(s);\n};\n\nRequest.prototype.end = function (s) {\n    if (s !== undefined) this.body.write(s);\n    this.body.end()\n    this.xhr.send(this.body.getBody());\n};\n\n// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html\nRequest.unsafeHeaders = [\n    \"accept-charset\",\n    \"accept-encoding\",\n    \"access-control-request-headers\",\n    \"access-control-request-method\",\n    \"connection\",\n    \"content-length\",\n    \"cookie\",\n    \"cookie2\",\n    \"content-transfer-encoding\",\n    \"date\",\n    \"expect\",\n    \"host\",\n    \"keep-alive\",\n    \"origin\",\n    \"referer\",\n    \"te\",\n    \"trailer\",\n    \"transfer-encoding\",\n    \"upgrade\",\n    \"user-agent\",\n    \"via\"\n];\n\nRequest.prototype.isSafeRequestHeader = function (headerName) {\n    if (!headerName) return false;\n    return (Request.unsafeHeaders.indexOf(headerName.toLowerCase()) === -1)\n};\n\n//@ sourceURL=/node_modules/http-browserify/lib/request.js"
));

require.define("/node_modules/http-browserify/lib/response.js",Function(['require','module','exports','__dirname','__filename','process'],"var EventEmitter = require('events').EventEmitter;\n\nvar Response = module.exports = function (res) {\n    this.offset = 0;\n};\n\nResponse.prototype = new EventEmitter;\n\nvar capable = {\n    streaming : true,\n    status2 : true\n};\n\nfunction parseHeaders (res) {\n    var lines = res.getAllResponseHeaders().split(/\\r?\\n/);\n    var headers = {};\n    for (var i = 0; i < lines.length; i++) {\n        var line = lines[i];\n        if (line === '') continue;\n        \n        var m = line.match(/^([^:]+):\\s*(.*)/);\n        if (m) {\n            var key = m[1].toLowerCase(), value = m[2];\n            \n            if (headers[key] !== undefined) {\n                if ((Array.isArray && Array.isArray(headers[key]))\n                || headers[key] instanceof Array) {\n                    headers[key].push(value);\n                }\n                else {\n                    headers[key] = [ headers[key], value ];\n                }\n            }\n            else {\n                headers[key] = value;\n            }\n        }\n        else {\n            headers[line] = true;\n        }\n    }\n    return headers;\n}\n\nResponse.prototype.getResponse = function (xhr) {\n    var respType = xhr.responseType.toLowerCase();\n    if (respType === \"blob\") return xhr.responseBlob;\n    if (respType === \"arraybuffer\") return xhr.response;\n    return xhr.responseText;\n}\n\nResponse.prototype.getHeader = function (key) {\n    return this.headers[key.toLowerCase()];\n};\n\nResponse.prototype.handle = function (res) {\n    if (res.readyState === 2 && capable.status2) {\n        try {\n            this.statusCode = res.status;\n            this.headers = parseHeaders(res);\n        }\n        catch (err) {\n            capable.status2 = false;\n        }\n        \n        if (capable.status2) {\n            this.emit('ready');\n        }\n    }\n    else if (capable.streaming && res.readyState === 3) {\n        try {\n            if (!this.statusCode) {\n                this.statusCode = res.status;\n                this.headers = parseHeaders(res);\n                this.emit('ready');\n            }\n        }\n        catch (err) {}\n        \n        try {\n            this.write(res);\n        }\n        catch (err) {\n            capable.streaming = false;\n        }\n    }\n    else if (res.readyState === 4) {\n        if (!this.statusCode) {\n            this.statusCode = res.status;\n            this.emit('ready');\n        }\n        this.write(res);\n        \n        if (res.error) {\n            this.emit('error', this.getResponse(res));\n        }\n        else this.emit('end');\n    }\n};\n\nResponse.prototype.write = function (res) {\n    var respBody = this.getResponse(res);\n    if (respBody.toString().match(/ArrayBuffer/)) {\n        this.emit('data', new Uint8Array(respBody, this.offset));\n        this.offset = respBody.byteLength;\n        return;\n    }\n    if (respBody.length > this.offset) {\n        this.emit('data', respBody.slice(this.offset));\n        this.offset = respBody.length;\n    }\n};\n\n//@ sourceURL=/node_modules/http-browserify/lib/response.js"
));

require.define("/node_modules/http-browserify/node_modules/concat-stream/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/http-browserify/node_modules/concat-stream/package.json"
));

require.define("/node_modules/http-browserify/node_modules/concat-stream/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var stream = require('stream')\nvar util = require('util')\n\nfunction ConcatStream(cb) {\n  stream.Stream.call(this)\n  this.writable = true\n  if (cb) this.cb = cb\n  this.body = []\n  if (this.cb) this.on('error', cb)\n}\n\nutil.inherits(ConcatStream, stream.Stream)\n\nConcatStream.prototype.write = function(chunk) {\n  this.body.push(chunk)\n}\n\nConcatStream.prototype.arrayConcat = function(arrs) {\n  if (arrs.length === 0) return []\n  if (arrs.length === 1) return arrs[0]\n  return arrs.reduce(function (a, b) { return a.concat(b) })\n}\n\nConcatStream.prototype.isArray = function(arr) {\n  var isArray = Array.isArray(arr)\n  var isTypedArray = arr.toString().match(/Array/)\n  return isArray || isTypedArray\n}\n\nConcatStream.prototype.getBody = function () {\n  if (this.body.length === 0) return\n  if (typeof(this.body[0]) === \"string\") return this.body.join('')\n  if (this.isArray(this.body[0])) return this.arrayConcat(this.body)\n  if (typeof(Buffer) !== \"undefined\" && Buffer.isBuffer(this.body[0])) {\n    return Buffer.concat(this.body)\n  }\n  return this.body\n}\n\nConcatStream.prototype.end = function() {\n  if (this.cb) this.cb(false, this.getBody())\n}\n\nmodule.exports = function(cb) {\n  return new ConcatStream(cb)\n}\n\nmodule.exports.ConcatStream = ConcatStream\n\n//@ sourceURL=/node_modules/http-browserify/node_modules/concat-stream/index.js"
));

require.define("url",Function(['require','module','exports','__dirname','__filename','process'],"var punycode = { encode : function (s) { return s } };\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nfunction arrayIndexOf(array, subject) {\n    for (var i = 0, j = array.length; i < j; i++) {\n        if(array[i] == subject) return i;\n    }\n    return -1;\n}\n\nvar objectKeys = Object.keys || function objectKeys(object) {\n    if (object !== Object(object)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;\n    return keys;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]+$/,\n    // RFC 2396: characters reserved for delimiting URLs.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '~', '[', ']', '`'].concat(delims),\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''],\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#']\n      .concat(unwise).concat(autoEscape),\n    nonAuthChars = ['/', '@', '?', '#'].concat(delims),\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-zA-Z0-9][a-z0-9A-Z_-]{0,62}$/,\n    hostnamePartStart = /^([a-zA-Z0-9][a-z0-9A-Z_-]{0,62})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always have a path component.\n    pathedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && typeof(url) === 'object' && url.href) return url;\n\n  if (typeof url !== 'string') {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  var out = {},\n      rest = url;\n\n  // cut off any delimiters.\n  // This is to support parse stuff like \"<http://foo.com>\"\n  for (var i = 0, l = rest.length; i < l; i++) {\n    if (arrayIndexOf(delims, rest.charAt(i)) === -1) break;\n  }\n  if (i !== 0) rest = rest.substr(i);\n\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    out.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      out.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    // don't enforce full RFC correctness, just be unstupid about it.\n\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the first @ sign, unless some non-auth character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    var atSign = arrayIndexOf(rest, '@');\n    if (atSign !== -1) {\n      // there *may be* an auth\n      var hasAuth = true;\n      for (var i = 0, l = nonAuthChars.length; i < l; i++) {\n        var index = arrayIndexOf(rest, nonAuthChars[i]);\n        if (index !== -1 && index < atSign) {\n          // not a valid auth.  Something like http://foo.com/bar@baz/\n          hasAuth = false;\n          break;\n        }\n      }\n      if (hasAuth) {\n        // pluck off the auth portion.\n        out.auth = rest.substr(0, atSign);\n        rest = rest.substr(atSign + 1);\n      }\n    }\n\n    var firstNonHost = -1;\n    for (var i = 0, l = nonHostChars.length; i < l; i++) {\n      var index = arrayIndexOf(rest, nonHostChars[i]);\n      if (index !== -1 &&\n          (firstNonHost < 0 || index < firstNonHost)) firstNonHost = index;\n    }\n\n    if (firstNonHost !== -1) {\n      out.host = rest.substr(0, firstNonHost);\n      rest = rest.substr(firstNonHost);\n    } else {\n      out.host = rest;\n      rest = '';\n    }\n\n    // pull out port.\n    var p = parseHost(out.host);\n    var keys = objectKeys(p);\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      out[key] = p[key];\n    }\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    out.hostname = out.hostname || '';\n\n    // validate a little.\n    if (out.hostname.length > hostnameMaxLen) {\n      out.hostname = '';\n    } else {\n      var hostparts = out.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            out.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    // hostnames are always lower case.\n    out.hostname = out.hostname.toLowerCase();\n\n    // IDNA Support: Returns a puny coded representation of \"domain\".\n    // It only converts the part of the domain name that\n    // has non ASCII characters. I.e. it dosent matter if\n    // you call it with a domain that already is in ASCII.\n    var domainArray = out.hostname.split('.');\n    var newOut = [];\n    for (var i = 0; i < domainArray.length; ++i) {\n      var s = domainArray[i];\n      newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n          'xn--' + punycode.encode(s) : s);\n    }\n    out.hostname = newOut.join('.');\n\n    out.host = (out.hostname || '') +\n        ((out.port) ? ':' + out.port : '');\n    out.href += out.host;\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n\n    // Now make sure that delims never appear in a url.\n    var chop = rest.length;\n    for (var i = 0, l = delims.length; i < l; i++) {\n      var c = arrayIndexOf(rest, delims[i]);\n      if (c !== -1) {\n        chop = Math.min(c, chop);\n      }\n    }\n    rest = rest.substr(0, chop);\n  }\n\n\n  // chop off from the tail first.\n  var hash = arrayIndexOf(rest, '#');\n  if (hash !== -1) {\n    // got a fragment string.\n    out.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = arrayIndexOf(rest, '?');\n  if (qm !== -1) {\n    out.search = rest.substr(qm);\n    out.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      out.query = querystring.parse(out.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    out.search = '';\n    out.query = {};\n  }\n  if (rest) out.pathname = rest;\n  if (slashedProtocol[proto] &&\n      out.hostname && !out.pathname) {\n    out.pathname = '/';\n  }\n\n  //to support http.request\n  if (out.pathname || out.search) {\n    out.path = (out.pathname ? out.pathname : '') +\n               (out.search ? out.search : '');\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  out.href = urlFormat(out);\n  return out;\n}\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (typeof(obj) === 'string') obj = urlParse(obj);\n\n  var auth = obj.auth || '';\n  if (auth) {\n    auth = auth.split('@').join('%40');\n    for (var i = 0, l = nonAuthChars.length; i < l; i++) {\n      var nAC = nonAuthChars[i];\n      auth = auth.split(nAC).join(encodeURIComponent(nAC));\n    }\n    auth += '@';\n  }\n\n  var protocol = obj.protocol || '',\n      host = (obj.host !== undefined) ? auth + obj.host :\n          obj.hostname !== undefined ? (\n              auth + obj.hostname +\n              (obj.port ? ':' + obj.port : '')\n          ) :\n          false,\n      pathname = obj.pathname || '',\n      query = obj.query &&\n              ((typeof obj.query === 'object' &&\n                objectKeys(obj.query).length) ?\n                 querystring.stringify(obj.query) :\n                 '') || '',\n      search = obj.search || (query && ('?' + query)) || '',\n      hash = obj.hash || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (obj.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  return protocol + host + pathname + search + hash;\n}\n\nfunction urlResolve(source, relative) {\n  return urlFormat(urlResolveObject(source, relative));\n}\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n\n  source = urlParse(urlFormat(source), false, true);\n  relative = urlParse(urlFormat(relative), false, true);\n\n  // hash is always overridden, no matter what.\n  source.hash = relative.hash;\n\n  if (relative.href === '') {\n    source.href = urlFormat(source);\n    return source;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    relative.protocol = source.protocol;\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[relative.protocol] &&\n        relative.hostname && !relative.pathname) {\n      relative.path = relative.pathname = '/';\n    }\n    relative.href = urlFormat(relative);\n    return relative;\n  }\n\n  if (relative.protocol && relative.protocol !== source.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      relative.href = urlFormat(relative);\n      return relative;\n    }\n    source.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      relative.pathname = relPath.join('/');\n    }\n    source.pathname = relative.pathname;\n    source.search = relative.search;\n    source.query = relative.query;\n    source.host = relative.host || '';\n    source.auth = relative.auth;\n    source.hostname = relative.hostname || relative.host;\n    source.port = relative.port;\n    //to support http.request\n    if (source.pathname !== undefined || source.search !== undefined) {\n      source.path = (source.pathname ? source.pathname : '') +\n                    (source.search ? source.search : '');\n    }\n    source.slashes = source.slashes || relative.slashes;\n    source.href = urlFormat(source);\n    return source;\n  }\n\n  var isSourceAbs = (source.pathname && source.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host !== undefined ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (source.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = source.pathname && source.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = source.protocol &&\n          !slashedProtocol[source.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // source.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n\n    delete source.hostname;\n    delete source.port;\n    if (source.host) {\n      if (srcPath[0] === '') srcPath[0] = source.host;\n      else srcPath.unshift(source.host);\n    }\n    delete source.host;\n    if (relative.protocol) {\n      delete relative.hostname;\n      delete relative.port;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      delete relative.host;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    source.host = (relative.host || relative.host === '') ?\n                      relative.host : source.host;\n    source.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : source.hostname;\n    source.search = relative.search;\n    source.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    source.search = relative.search;\n    source.query = relative.query;\n  } else if ('search' in relative) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      source.hostname = source.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especialy happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?\n                       source.host.split('@') : false;\n      if (authInHost) {\n        source.auth = authInHost.shift();\n        source.host = source.hostname = authInHost.shift();\n      }\n    }\n    source.search = relative.search;\n    source.query = relative.query;\n    //to support http.request\n    if (source.pathname !== undefined || source.search !== undefined) {\n      source.path = (source.pathname ? source.pathname : '') +\n                    (source.search ? source.search : '');\n    }\n    source.href = urlFormat(source);\n    return source;\n  }\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    delete source.pathname;\n    //to support http.request\n    if (!source.search) {\n      source.path = '/' + source.search;\n    } else {\n      delete source.path;\n    }\n    source.href = urlFormat(source);\n    return source;\n  }\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (source.host || relative.host) && (last === '.' || last === '..') ||\n      last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    source.hostname = source.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especialy happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = source.host && arrayIndexOf(source.host, '@') > 0 ?\n                     source.host.split('@') : false;\n    if (authInHost) {\n      source.auth = authInHost.shift();\n      source.host = source.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (source.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  source.pathname = srcPath.join('/');\n  //to support request.http\n  if (source.pathname !== undefined || source.search !== undefined) {\n    source.path = (source.pathname ? source.pathname : '') +\n                  (source.search ? source.search : '');\n  }\n  source.auth = relative.auth || source.auth;\n  source.slashes = source.slashes || relative.slashes;\n  source.href = urlFormat(source);\n  return source;\n}\n\nfunction parseHost(host) {\n  var out = {};\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    out.port = port.substr(1);\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) out.hostname = host;\n  return out;\n}\n\n//@ sourceURL=url"
));

require.define("querystring",Function(['require','module','exports','__dirname','__filename','process'],"var isArray = typeof Array.isArray === 'function'\n    ? Array.isArray\n    : function (xs) {\n        return Object.prototype.toString.call(xs) === '[object Array]'\n    };\n\nvar objectKeys = Object.keys || function objectKeys(object) {\n    if (object !== Object(object)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in object) if (object.hasOwnProperty(key)) keys[keys.length] = key;\n    return keys;\n}\n\n\n/*!\n * querystring\n * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n/**\n * Library version.\n */\n\nexports.version = '0.3.1';\n\n/**\n * Object#toString() ref for stringify().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Cache non-integer test regexp.\n */\n\nvar notint = /[^0-9]/;\n\n/**\n * Parse the given query `str`, returning an object.\n *\n * @param {String} str\n * @return {Object}\n * @api public\n */\n\nexports.parse = function(str){\n  if (null == str || '' == str) return {};\n\n  function promote(parent, key) {\n    if (parent[key].length == 0) return parent[key] = {};\n    var t = {};\n    for (var i in parent[key]) t[i] = parent[key][i];\n    parent[key] = t;\n    return t;\n  }\n\n  return String(str)\n    .split('&')\n    .reduce(function(ret, pair){\n      try{ \n        pair = decodeURIComponent(pair.replace(/\\+/g, ' '));\n      } catch(e) {\n        // ignore\n      }\n\n      var eql = pair.indexOf('=')\n        , brace = lastBraceInKey(pair)\n        , key = pair.substr(0, brace || eql)\n        , val = pair.substr(brace || eql, pair.length)\n        , val = val.substr(val.indexOf('=') + 1, val.length)\n        , parent = ret;\n\n      // ?foo\n      if ('' == key) key = pair, val = '';\n\n      // nested\n      if (~key.indexOf(']')) {\n        var parts = key.split('[')\n          , len = parts.length\n          , last = len - 1;\n\n        function parse(parts, parent, key) {\n          var part = parts.shift();\n\n          // end\n          if (!part) {\n            if (isArray(parent[key])) {\n              parent[key].push(val);\n            } else if ('object' == typeof parent[key]) {\n              parent[key] = val;\n            } else if ('undefined' == typeof parent[key]) {\n              parent[key] = val;\n            } else {\n              parent[key] = [parent[key], val];\n            }\n          // array\n          } else {\n            obj = parent[key] = parent[key] || [];\n            if (']' == part) {\n              if (isArray(obj)) {\n                if ('' != val) obj.push(val);\n              } else if ('object' == typeof obj) {\n                obj[objectKeys(obj).length] = val;\n              } else {\n                obj = parent[key] = [parent[key], val];\n              }\n            // prop\n            } else if (~part.indexOf(']')) {\n              part = part.substr(0, part.length - 1);\n              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);\n              parse(parts, obj, part);\n            // key\n            } else {\n              if(notint.test(part) && isArray(obj)) obj = promote(parent, key);\n              parse(parts, obj, part);\n            }\n          }\n        }\n\n        parse(parts, parent, 'base');\n      // optimize\n      } else {\n        if (notint.test(key) && isArray(parent.base)) {\n          var t = {};\n          for(var k in parent.base) t[k] = parent.base[k];\n          parent.base = t;\n        }\n        set(parent.base, key, val);\n      }\n\n      return ret;\n    }, {base: {}}).base;\n};\n\n/**\n * Turn the given `obj` into a query string\n *\n * @param {Object} obj\n * @return {String}\n * @api public\n */\n\nvar stringify = exports.stringify = function(obj, prefix) {\n  if (isArray(obj)) {\n    return stringifyArray(obj, prefix);\n  } else if ('[object Object]' == toString.call(obj)) {\n    return stringifyObject(obj, prefix);\n  } else if ('string' == typeof obj) {\n    return stringifyString(obj, prefix);\n  } else {\n    return prefix;\n  }\n};\n\n/**\n * Stringify the given `str`.\n *\n * @param {String} str\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyString(str, prefix) {\n  if (!prefix) throw new TypeError('stringify expects an object');\n  return prefix + '=' + encodeURIComponent(str);\n}\n\n/**\n * Stringify the given `arr`.\n *\n * @param {Array} arr\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyArray(arr, prefix) {\n  var ret = [];\n  if (!prefix) throw new TypeError('stringify expects an object');\n  for (var i = 0; i < arr.length; i++) {\n    ret.push(stringify(arr[i], prefix + '[]'));\n  }\n  return ret.join('&');\n}\n\n/**\n * Stringify the given `obj`.\n *\n * @param {Object} obj\n * @param {String} prefix\n * @return {String}\n * @api private\n */\n\nfunction stringifyObject(obj, prefix) {\n  var ret = []\n    , keys = objectKeys(obj)\n    , key;\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    key = keys[i];\n    ret.push(stringify(obj[key], prefix\n      ? prefix + '[' + encodeURIComponent(key) + ']'\n      : encodeURIComponent(key)));\n  }\n  return ret.join('&');\n}\n\n/**\n * Set `obj`'s `key` to `val` respecting\n * the weird and wonderful syntax of a qs,\n * where \"foo=bar&foo=baz\" becomes an array.\n *\n * @param {Object} obj\n * @param {String} key\n * @param {String} val\n * @api private\n */\n\nfunction set(obj, key, val) {\n  var v = obj[key];\n  if (undefined === v) {\n    obj[key] = val;\n  } else if (isArray(v)) {\n    v.push(val);\n  } else {\n    obj[key] = [v, val];\n  }\n}\n\n/**\n * Locate last brace in `str` within the key.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction lastBraceInKey(str) {\n  var len = str.length\n    , brace\n    , c;\n  for (var i = 0; i < len; ++i) {\n    c = str[i];\n    if (']' == c) brace = false;\n    if ('[' == c) brace = true;\n    if ('=' == c && !brace) return i;\n  }\n}\n\n//@ sourceURL=querystring"
));

require.define("/node_modules/request/mimetypes.js",Function(['require','module','exports','__dirname','__filename','process'],"// from http://github.com/felixge/node-paperboy\nexports.types = {\n  \"aiff\":\"audio/x-aiff\",\n  \"arj\":\"application/x-arj-compressed\",\n  \"asf\":\"video/x-ms-asf\",\n  \"asx\":\"video/x-ms-asx\",\n  \"au\":\"audio/ulaw\",\n  \"avi\":\"video/x-msvideo\",\n  \"bcpio\":\"application/x-bcpio\",\n  \"ccad\":\"application/clariscad\",\n  \"cod\":\"application/vnd.rim.cod\",\n  \"com\":\"application/x-msdos-program\",\n  \"cpio\":\"application/x-cpio\",\n  \"cpt\":\"application/mac-compactpro\",\n  \"csh\":\"application/x-csh\",\n  \"css\":\"text/css\",\n  \"deb\":\"application/x-debian-package\",\n  \"dl\":\"video/dl\",\n  \"doc\":\"application/msword\",\n  \"drw\":\"application/drafting\",\n  \"dvi\":\"application/x-dvi\",\n  \"dwg\":\"application/acad\",\n  \"dxf\":\"application/dxf\",\n  \"dxr\":\"application/x-director\",\n  \"etx\":\"text/x-setext\",\n  \"ez\":\"application/andrew-inset\",\n  \"fli\":\"video/x-fli\",\n  \"flv\":\"video/x-flv\",\n  \"gif\":\"image/gif\",\n  \"gl\":\"video/gl\",\n  \"gtar\":\"application/x-gtar\",\n  \"gz\":\"application/x-gzip\",\n  \"hdf\":\"application/x-hdf\",\n  \"hqx\":\"application/mac-binhex40\",\n  \"html\":\"text/html\",\n  \"ice\":\"x-conference/x-cooltalk\",\n  \"ico\":\"image/x-icon\",\n  \"ief\":\"image/ief\",\n  \"igs\":\"model/iges\",\n  \"ips\":\"application/x-ipscript\",\n  \"ipx\":\"application/x-ipix\",\n  \"jad\":\"text/vnd.sun.j2me.app-descriptor\",\n  \"jar\":\"application/java-archive\",\n  \"jpeg\":\"image/jpeg\",\n  \"jpg\":\"image/jpeg\",\n  \"js\":\"text/javascript\",\n  \"json\":\"application/json\",\n  \"latex\":\"application/x-latex\",\n  \"lsp\":\"application/x-lisp\",\n  \"lzh\":\"application/octet-stream\",\n  \"m\":\"text/plain\",\n  \"m3u\":\"audio/x-mpegurl\",\n  \"man\":\"application/x-troff-man\",\n  \"me\":\"application/x-troff-me\",\n  \"midi\":\"audio/midi\",\n  \"mif\":\"application/x-mif\",\n  \"mime\":\"www/mime\",\n  \"movie\":\"video/x-sgi-movie\",\n  \"mustache\":\"text/plain\",\n  \"mp4\":\"video/mp4\",\n  \"mpg\":\"video/mpeg\",\n  \"mpga\":\"audio/mpeg\",\n  \"ms\":\"application/x-troff-ms\",\n  \"nc\":\"application/x-netcdf\",\n  \"oda\":\"application/oda\",\n  \"ogm\":\"application/ogg\",\n  \"pbm\":\"image/x-portable-bitmap\",\n  \"pdf\":\"application/pdf\",\n  \"pgm\":\"image/x-portable-graymap\",\n  \"pgn\":\"application/x-chess-pgn\",\n  \"pgp\":\"application/pgp\",\n  \"pm\":\"application/x-perl\",\n  \"png\":\"image/png\",\n  \"pnm\":\"image/x-portable-anymap\",\n  \"ppm\":\"image/x-portable-pixmap\",\n  \"ppz\":\"application/vnd.ms-powerpoint\",\n  \"pre\":\"application/x-freelance\",\n  \"prt\":\"application/pro_eng\",\n  \"ps\":\"application/postscript\",\n  \"qt\":\"video/quicktime\",\n  \"ra\":\"audio/x-realaudio\",\n  \"rar\":\"application/x-rar-compressed\",\n  \"ras\":\"image/x-cmu-raster\",\n  \"rgb\":\"image/x-rgb\",\n  \"rm\":\"audio/x-pn-realaudio\",\n  \"rpm\":\"audio/x-pn-realaudio-plugin\",\n  \"rtf\":\"text/rtf\",\n  \"rtx\":\"text/richtext\",\n  \"scm\":\"application/x-lotusscreencam\",\n  \"set\":\"application/set\",\n  \"sgml\":\"text/sgml\",\n  \"sh\":\"application/x-sh\",\n  \"shar\":\"application/x-shar\",\n  \"silo\":\"model/mesh\",\n  \"sit\":\"application/x-stuffit\",\n  \"skt\":\"application/x-koan\",\n  \"smil\":\"application/smil\",\n  \"snd\":\"audio/basic\",\n  \"sol\":\"application/solids\",\n  \"spl\":\"application/x-futuresplash\",\n  \"src\":\"application/x-wais-source\",\n  \"stl\":\"application/SLA\",\n  \"stp\":\"application/STEP\",\n  \"sv4cpio\":\"application/x-sv4cpio\",\n  \"sv4crc\":\"application/x-sv4crc\",\n  \"svg\":\"image/svg+xml\",\n  \"swf\":\"application/x-shockwave-flash\",\n  \"tar\":\"application/x-tar\",\n  \"tcl\":\"application/x-tcl\",\n  \"tex\":\"application/x-tex\",\n  \"texinfo\":\"application/x-texinfo\",\n  \"tgz\":\"application/x-tar-gz\",\n  \"tiff\":\"image/tiff\",\n  \"tr\":\"application/x-troff\",\n  \"tsi\":\"audio/TSP-audio\",\n  \"tsp\":\"application/dsptype\",\n  \"tsv\":\"text/tab-separated-values\",\n  \"unv\":\"application/i-deas\",\n  \"ustar\":\"application/x-ustar\",\n  \"vcd\":\"application/x-cdlink\",\n  \"vda\":\"application/vda\",\n  \"vivo\":\"video/vnd.vivo\",\n  \"vrm\":\"x-world/x-vrml\",\n  \"wav\":\"audio/x-wav\",\n  \"wax\":\"audio/x-ms-wax\",\n  \"wma\":\"audio/x-ms-wma\",\n  \"wmv\":\"video/x-ms-wmv\",\n  \"wmx\":\"video/x-ms-wmx\",\n  \"wrl\":\"model/vrml\",\n  \"wvx\":\"video/x-ms-wvx\",\n  \"xbm\":\"image/x-xbitmap\",\n  \"xlw\":\"application/vnd.ms-excel\",\n  \"xml\":\"text/xml\",\n  \"xpm\":\"image/x-xpixmap\",\n  \"xwd\":\"image/x-xwindowdump\",\n  \"xyz\":\"chemical/x-pdb\",\n  \"zip\":\"application/zip\",\n};\n\nexports.lookup = function(ext, defaultType) {\n  defaultType = defaultType || 'application/octet-stream';\n\n  return (ext in exports.types)\n    ? exports.types[ext]\n    : defaultType;\n};\n//@ sourceURL=/node_modules/request/mimetypes.js"
));

require.define("/node_modules/request/oauth.js",Function(['require','module','exports','__dirname','__filename','process'],"var crypto = require('crypto')\n  , qs = require('querystring')\n  ;\n\nfunction sha1 (key, body) {\n  return crypto.createHmac('sha1', key).update(body).digest('base64')\n}\n\nfunction rfc3986 (str) {\n  return encodeURIComponent(str)\n    .replace('!','%21')\n    .replace('*','%2A')\n    .replace('(','%28')\n    .replace(')','%29')\n    .replace(\"'\",'%27')\n    ;\n}\n\nfunction hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret, body) {\n  // adapted from https://dev.twitter.com/docs/auth/oauth\n  var base = \n    httpMethod + \"&\" +\n    encodeURIComponent(  base_uri ) + \"&\" +\n    Object.keys(params).sort().map(function (i) {\n      // big WTF here with the escape + encoding but it's what twitter wants\n      return escape(rfc3986(i)) + \"%3D\" + escape(rfc3986(params[i]))\n    }).join(\"%26\")\n  var key = consumer_secret + '&'\n  if (token_secret) key += token_secret\n  return sha1(key, base)\n}\n\nexports.hmacsign = hmacsign\nexports.rfc3986 = rfc3986\n//@ sourceURL=/node_modules/request/oauth.js"
));

require.define("crypto",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require(\"crypto-browserify\")\n//@ sourceURL=crypto"
));

require.define("/node_modules/crypto-browserify/package.json",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = {}\n//@ sourceURL=/node_modules/crypto-browserify/package.json"
));

require.define("/node_modules/crypto-browserify/index.js",Function(['require','module','exports','__dirname','__filename','process'],"var sha = require('./sha')\nvar rng = require('./rng')\n\nvar algorithms = {\n  sha1: {\n    hex: sha.hex_sha1,\n    binary: sha.b64_sha1,\n    ascii: sha.str_sha1\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(' ')\n  throw new Error([\n    m,\n    'we accept pull requests',\n    'http://github.com/dominictarr/crypto-browserify'\n    ].join('\\n'))\n}\n\nexports.createHash = function (alg) {\n  alg = alg || 'sha1'\n  if(!algorithms[alg])\n    error('algorithm:', alg, 'is not yet supported')\n  var s = ''\n  var _alg = algorithms[alg]\n  return {\n    update: function (data) {\n      s += data\n      return this\n    },\n    digest: function (enc) {\n      enc = enc || 'binary'\n      var fn\n      if(!(fn = _alg[enc]))\n        error('encoding:', enc , 'is not yet supported for algorithm', alg)\n      var r = fn(s)\n      s = null //not meant to use the hash after you've called digest.\n      return r\n    }\n  }\n}\n\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, rng(size));\n    } catch (err) { callback(err); }\n  } else {\n    return rng(size);\n  }\n}\n\n// the least I can do is make error messages for the rest of the node.js/crypto api.\n;['createCredentials'\n, 'createHmac'\n, 'createCypher'\n, 'createCypheriv'\n, 'createDecipher'\n, 'createDecipheriv'\n, 'createSign'\n, 'createVerify'\n, 'createDeffieHellman'\n, 'pbkdf2'].forEach(function (name) {\n  exports[name] = function () {\n    error('sorry,', name, 'is not implemented yet')\n  }\n})\n\n//@ sourceURL=/node_modules/crypto-browserify/index.js"
));

require.define("/node_modules/crypto-browserify/sha.js",Function(['require','module','exports','__dirname','__filename','process'],"/*\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\n * in FIPS PUB 180-1\n * Version 2.1a Copyright Paul Johnston 2000 - 2002.\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for details.\n */\n\nexports.hex_sha1 = hex_sha1;\nexports.b64_sha1 = b64_sha1;\nexports.str_sha1 = str_sha1;\nexports.hex_hmac_sha1 = hex_hmac_sha1;\nexports.b64_hmac_sha1 = b64_hmac_sha1;\nexports.str_hmac_sha1 = str_hmac_sha1;\n\n/*\n * Configurable variables. You may need to tweak these to be compatible with\n * the server-side, but the defaults work in most cases.\n */\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\nvar chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */\n\n/*\n * These are the functions you'll usually want to call\n * They take string arguments and return either hex or base-64 encoded strings\n */\nfunction hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}\nfunction b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}\nfunction str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}\nfunction hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}\nfunction b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}\nfunction str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}\n\n/*\n * Perform a simple self-test to see if the VM is working\n */\nfunction sha1_vm_test()\n{\n  return hex_sha1(\"abc\") == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\n}\n\n/*\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\n */\nfunction core_sha1(x, len)\n{\n  /* append padding */\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n/*\n * Perform the appropriate triplet combination function for the current\n * iteration\n */\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n/*\n * Determine the appropriate additive constant for the current iteration\n */\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n/*\n * Calculate the HMAC-SHA1 of a key and some data\n */\nfunction core_hmac_sha1(key, data)\n{\n  var bkey = str2binb(key);\n  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);\n\n  var ipad = Array(16), opad = Array(16);\n  for(var i = 0; i < 16; i++)\n  {\n    ipad[i] = bkey[i] ^ 0x36363636;\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\n  }\n\n  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);\n  return core_sha1(opad.concat(hash), 512 + 160);\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\n/*\n * Convert an 8-bit or 16-bit string to an array of big-endian words\n * In 8-bit function, characters >255 have their hi-byte silently ignored.\n */\nfunction str2binb(str)\n{\n  var bin = Array();\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < str.length * chrsz; i += chrsz)\n    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);\n  return bin;\n}\n\n/*\n * Convert an array of big-endian words to a string\n */\nfunction binb2str(bin)\n{\n  var str = \"\";\n  var mask = (1 << chrsz) - 1;\n  for(var i = 0; i < bin.length * 32; i += chrsz)\n    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a hex string.\n */\nfunction binb2hex(binarray)\n{\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i++)\n  {\n    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +\n           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);\n  }\n  return str;\n}\n\n/*\n * Convert an array of big-endian words to a base-64 string\n */\nfunction binb2b64(binarray)\n{\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  var str = \"\";\n  for(var i = 0; i < binarray.length * 4; i += 3)\n  {\n    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)\n                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )\n                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);\n    for(var j = 0; j < 4; j++)\n    {\n      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;\n      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);\n    }\n  }\n  return str;\n}\n\n\n//@ sourceURL=/node_modules/crypto-browserify/sha.js"
));

require.define("/node_modules/crypto-browserify/rng.js",Function(['require','module','exports','__dirname','__filename','process'],"// Original code adapted from Robert Kieffer.\n// details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  // NOTE: Math.random() does not guarantee \"cryptographic quality\"\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  // currently only available in webkit-based browsers.\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function(size) {\n      var bytes = new Array(size);\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < size; c++) {\n        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n//@ sourceURL=/node_modules/crypto-browserify/rng.js"
));

require.define("/node_modules/request/uuid.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = function () {\n  var s = [], itoh = '0123456789ABCDEF';\n \n  // Make array of random hex digits. The UUID only has 32 digits in it, but we\n  // allocate an extra items to make room for the '-'s we'll be inserting.\n  for (var i = 0; i <36; i++) s[i] = Math.floor(Math.random()*0x10);\n \n  // Conform to RFC-4122, section 4.4\n  s[14] = 4;  // Set 4 high bits of time_high field to version\n  s[19] = (s[19] & 0x3) | 0x8;  // Specify 2 high bits of clock sequence\n \n  // Convert to hex chars\n  for (var i = 0; i <36; i++) s[i] = itoh[s[i]];\n \n  // Insert '-'s\n  s[8] = s[13] = s[18] = s[23] = '-';\n \n  return s.join('');\n}\n\n//@ sourceURL=/node_modules/request/uuid.js"
));

require.define("/node_modules/request/forever.js",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = ForeverAgent\n\nvar util = require('util')\n  , Agent = require('http').Agent\n  , net = require('net')\n\nfunction ForeverAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.requests = {}\n  self.sockets = {}\n  self.freeSockets = {}\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n  self.on('free', function(socket, host, port) {\n    var name = host + ':' + port\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket)\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\n      self.freeSockets[name].push(socket)\n      \n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      function onIdleError() {\n        socket.destroy()\n      }\n      socket._onIdleError = onIdleError\n      socket.on('error', onIdleError)\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy();\n    }\n  })\n  self.createConnection = net.createConnection\n}\nutil.inherits(ForeverAgent, Agent)\n\nForeverAgent.defaultMinSockets = 5\n\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\nForeverAgent.prototype.addRequest = function(req, host, port) {\n  var name = host + ':' + port\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop()\n    idleSocket.removeListener('error', idleSocket._onIdleError)\n    delete idleSocket._onIdleError\n    req._reusedSocket = true\n    req.onSocket(idleSocket)\n  } else {\n    this.addRequestNoreuse(req, host, port)\n  }\n}\n\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s);\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1);\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name];\n    delete this.requests[name];\n  }\n  \n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s)\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1)\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name]\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free');\n  }\n}\n\n//@ sourceURL=/node_modules/request/forever.js"
));

require.define("net",Function(['require','module','exports','__dirname','__filename','process'],"// todo\n\n//@ sourceURL=net"
));

require.define("/node_modules/request/vendor/cookie/index.js",Function(['require','module','exports','__dirname','__filename','process'],"/*!\n * Tobi - Cookie\n * Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\n\nvar url = require('url');\n\n/**\n * Initialize a new `Cookie` with the given cookie `str` and `req`.\n *\n * @param {String} str\n * @param {IncomingRequest} req\n * @api private\n */\n\nvar Cookie = exports = module.exports = function Cookie(str, req) {\n  this.str = str;\n\n  // First key is the name\n  this.name = str.substr(0, str.indexOf('=')).trim();\n\n  // Map the key/val pairs\n  str.split(/ *; */).reduce(function(obj, pair){\n   var p = pair.indexOf('=');\n   if(p > 0)\n    obj[pair.substring(0, p).trim()] = pair.substring(p + 1).trim();\n   else\n    obj[pair.trim()] = true;\n   return obj;\n  }, this);\n\n  // Assign value\n  this.value = this[this.name];\n\n  // Expires\n  this.expires = this.expires\n    ? new Date(this.expires)\n    : Infinity;\n\n  // Default or trim path\n  this.path = this.path\n    ? this.path.trim(): req \n    ? url.parse(req.url).pathname: '/';\n};\n\n/**\n * Return the original cookie string.\n *\n * @return {String}\n * @api public\n */\n\nCookie.prototype.toString = function(){\n  return this.str;\n};\n\n//@ sourceURL=/node_modules/request/vendor/cookie/index.js"
));

require.define("/node_modules/request/vendor/cookie/jar.js",Function(['require','module','exports','__dirname','__filename','process'],"/*!\n* Tobi - CookieJar\n* Copyright(c) 2010 LearnBoost <dev@learnboost.com>\n* MIT Licensed\n*/\n\n/**\n* Module dependencies.\n*/\n\nvar url = require('url');\n\n/**\n* Initialize a new `CookieJar`.\n*\n* @api private\n*/\n\nvar CookieJar = exports = module.exports = function CookieJar() {\n  this.cookies = [];\n};\n\n/**\n* Add the given `cookie` to the jar.\n*\n* @param {Cookie} cookie\n* @api private\n*/\n\nCookieJar.prototype.add = function(cookie){\n  this.cookies = this.cookies.filter(function(c){\n    // Avoid duplication (same path, same name)\n    return !(c.name == cookie.name && c.path == cookie.path);\n  });\n  this.cookies.push(cookie);\n};\n\n/**\n* Get cookies for the given `req`.\n*\n* @param {IncomingRequest} req\n* @return {Array}\n* @api private\n*/\n\nCookieJar.prototype.get = function(req){\n  var path = url.parse(req.url).pathname\n    , now = new Date\n    , specificity = {};\n  return this.cookies.filter(function(cookie){\n    if (0 == path.indexOf(cookie.path) && now < cookie.expires\n      && cookie.path.length > (specificity[cookie.name] || 0))\n      return specificity[cookie.name] = cookie.path.length;\n  });\n};\n\n/**\n* Return Cookie string for the given `req`.\n*\n* @param {IncomingRequest} req\n* @return {String}\n* @api private\n*/\n\nCookieJar.prototype.cookieString = function(req){\n  var cookies = this.get(req);\n  if (cookies.length) {\n    return cookies.map(function(cookie){\n      return cookie.name + '=' + cookie.value;\n    }).join('; ');\n  }\n};\n\n//@ sourceURL=/node_modules/request/vendor/cookie/jar.js"
));

require.define("https",Function(['require','module','exports','__dirname','__filename','process'],"module.exports = require('http');\n\n//@ sourceURL=https"
));

require.define("tls",Function(['require','module','exports','__dirname','__filename','process'],"// todo\n\n//@ sourceURL=tls"
));

require.define("/example/JSONStream/160.js",Function(['require','module','exports','__dirname','__filename','process'],"// browser version\n\nvar JSONStream = require('JSONStream');\nvar request = require('request');\n\nvar parser = JSONStream.parse([ 'features', true, 'geometry', 'coordinates' ]);\n\nparser.on('data', function (coords) {\n    var div = document.createElement('div');\n    div.textContent = JSON.stringify(coords);\n    document.body.appendChild(div);\n});\n\nrequest('http://localhost:8005/data').pipe(parser);\n\n//@ sourceURL=/example/JSONStream/160.js"
));
require("/example/JSONStream/160.js");
})();
